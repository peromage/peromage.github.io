[{"content":"Google Photo sucks.\nWhen exporting photos from Google Photo, a bunch of JSON files come with your photos. Those JSON files contain metadata which is supposed to be stored with your photo files. If you simple import those photo files into another photo manager you will most likely not get a chronological view. Obviously, Google does on purpose so that you will not leave it easily. However, there is a workaround that is able to merge those metadata into your photos.\n Get exiftool: https://github.com/exiftool/exiftool Export your Google Photos and extract the downloaded compressed files into a folder Save the following content to fix-args.txt  # Usage: exiftool -@ fix-args.txt \u0026lt;takeout_dir\u0026gt; -r -d %s -tagsFromFile %d/%F.json -ext * --ext json -overwrite_original -progress -GPSAltitude\u0026lt;GeoDataAltitude -GPSLatitude\u0026lt;GeoDataLatitude -GPSLongitude\u0026lt;GeoDataLongitude -DateTimeOriginal\u0026lt;PhotoTakenTimeTimestamp -ModifyDate\u0026lt;PhotoLastModifiedTimeTimestamp -CreateDate\u0026lt;CreationTimeTimestamp -GPSAltitudeRef\u0026lt;GeoDataAltitude -GPSLatitudeRef\u0026lt;GeoDataLatitude -GPSLongitudeRef\u0026lt;GeoDataLongitude Execute exiftool -@ fix-args.txt \u0026lt;takeout_dir\u0026gt; Delete JSON files and import your photos to somewhere else  This argument file contains the fields that are meaningful to me. If you need to merge additional fields you can append them to the last. For details, check the man page of exiftool.\n","date":"2022-03-13T00:12:57Z","permalink":"https://peromage.github.io/p/fix-metadata-of-google-photo-takeout/","title":"Fix Metadata of Google Photo Takeout"},{"content":"This note is written for my personal convenience.\nServer Setup Installation $ sudo pacman -S shadowsocks-libev Shadowsocks Server Configuration Config file is located at /etc/shadowsocks/myserver.json.\nOn FreeBSD it is /usr/local/etc/shadowsocks/myserver.json\nThe file name can vary.\n{ \u0026#34;server\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, \u0026#34;server_port\u0026#34;: 8388, \u0026#34;password\u0026#34;: \u0026#34;mypassword\u0026#34;, \u0026#34;timeout\u0026#34;: 300, \u0026#34;method\u0026#34;: \u0026#34;chacha20-ietf-poly1305\u0026#34;, \u0026#34;fast_open\u0026#34;: false, \u0026#34;workers\u0026#34;: 1, \u0026#34;nameserver\u0026#34;: \u0026#34;8.8.8.8\u0026#34; } Note: For server, \u0026quot;local_address\u0026quot;: \u0026quot;127.0.0.1\u0026quot; and \u0026quot;local_port\u0026quot;: 1080 would cause problems so don\u0026rsquo;t them.\nStart Server (Not Persistent after Restart) $ ss-server -c /etc/shadowsocks/myserver.json \u0026amp; Start Server (As A System Service) Note: The config file name has to be placed after @.\n$ sudo systemctl enable shadowsocks-libev-server@myserver $ sudo systemctl start shadowsocks-libev-server@myserver Client Helper SS Access Key Generation Script (Bash Script) This script will prompt you to input parameters that are in the config file to generate a base64 encoded link.\n#!/usr/bin/bash # Usage: this_script.sh read -p \u0026#39;Method: \u0026#39; -r ss_method read -p \u0026#39;Password: \u0026#39; -r ss_password read -p \u0026#39;Server IP: \u0026#39; -r ss_server_ip read -p \u0026#39;Server Port: \u0026#39; -r ss_server_port echo \u0026#34;ss://\u0026#34; $(printf \u0026#34;${ss_method}:${ss_password}@${ss_server_ip}:${ss_server_port}\u0026#34; | base64) SS Access Key Generation Script (JavaScript) This approch requires Node.js but it can parse config file automatically.\n// Usage: node this_script.js \u0026lt;config_file\u0026gt; let argv = process.argv.slice(2); if (argv.length \u0026lt; 1) { console.log(\u0026#34;nothing\u0026#34;); return; } const fs = require(\u0026#39;fs\u0026#39;); let config_file = argv[0]; let config_json = JSON.parse(fs.readFileSync(config_file)); let ss_url = \u0026#34;ss://\u0026#34; + btoa(`${config_json[\u0026#39;method\u0026#39;]}:${config_json[\u0026#39;password\u0026#39;]}@${config_json[\u0026#39;server\u0026#39;][0]}:${config_json[\u0026#39;server_port\u0026#39;]}`); console.log(ss_url); ","date":"2022-03-13T00:03:36Z","permalink":"https://peromage.github.io/p/shadowsocks-quick-setup/","title":"Shadowsocks Quick Setup"},{"content":"This is a quick note of gpg-agent setup for SSH.\nQuick Setup  Import your GPG authentication key. Enable SSH support for gpg-agent.  $ echo enable-ssh-support \u0026gt;\u0026gt; $HOME/.gnupg/gpg-agent.conf Get the authentication keygrip.  $ gpg -k --with-keygrip Add the authentication key to the keychain (replace KEYGRIP with the value obtained from the previous step)  $ echo KEYGRIP \u0026gt;\u0026gt; $HOME/.gnupg/sshcontrol Add the following init code to .bashrc  unset SSH_AGENT_PID export SSH_AUTH_SOCK=\u0026#34;$(gpgconf --list-dirs agent-ssh-socket)\u0026#34; export GPG_TTY=\u0026#34;$(tty)\u0026#34; gpg-connect-agent updatestartuptty /bye \u0026gt; /dev/null Kill any running ssh-agent and gpg-agent, and then open a new Bash session.  Misc Export SSH Public Keys $ gpg --export-ssh-key \u0026lt;uid/fingerprint\u0026gt; ","date":"2022-03-13T00:02:12Z","permalink":"https://peromage.github.io/p/ssh-over-gpg-agent/","title":"SSH Over GPG Agent"},{"content":"Story Recently I\u0026rsquo;ve realized a fact that I always have needs to keep a multi-boot USB in my pocket for either Linux or Windows installation. There are a lot tools out there already but I don\u0026rsquo;t really like them. At least, I mean, they are too flashy to me. A beautiful boot menu seems not to be attractive. What I need is just a simple and practical maybe a little ugly boot device. It should be minimalist. More importantly, it has to be easy to setup with the tools on the system already and maintainable. No funky scripts.\nOld Solution - Clunky I\u0026rsquo;ve been using this solution for a very long time. Setup is pretty straight forward.\nThe partition scheme used on the USB drive is like (GPT):\n/dev/sda1 - 100 GB. NTFS. Data partition /dev/sda2 - 512 MB. FAT. EFI partition /dev/sda3 - 1 MB. No filesystem. BIOS boot partition used by GRUB /dev/sda4 - 8 GB. NTFS. Windows ISO files /dev/sda5 - 2 GB. FAT. Arch Linux ISO files So the idea is having a big data partition at the front for better access, then installing GRUB files on the second EFI partition with both EFI and BIOS support (Implemented by the third BIOS boot partition. The partition order doesn\u0026rsquo;t matter). Finally, create dedicated partitions to contain the extracted files from installation ISOs.\nWhen the USB drive is plugged in, I can use grub command line to chainload the EFI file that is located in the ISO partition, or the VBR if it\u0026rsquo;s booted with legacy mode.\nWell, it\u0026rsquo;s usable but I still feel that it is too much for a small USB drive - too many partitions. If I plug the drive in for just data exchange, there would be a a bunch of partitions mounted and the notification is quite annoying. So I started thinking that there must be a simpler way to do it.\nNew Solution - Much Better Partitioning The goal is simplicity so the new partition scheme is like this:\n/dev/sda1 - 100 GB. NTFS. Data partition /dev/sda2 - 512 MB. FAT. EFI partition /dev/sda3 - 1 MB. No filesystem. BIOS boot partition used by GRUB (Optional) The third BIOS boot partition is not really necessary since most of computers nowadays are using UEFI. If you really need the legacy compatibility, you can create one. I\u0026rsquo;ll keep it for now.\nInstalling GRUB Typical GRUB insallation but install for both EFI and BIOS.\n# mount /dev/sda2 /mnt # grub-install --target=x86_64-efi --efi-directory=/mnt --boot-directory=/mnt --removable # grub-install --target=i386-pc --boot-directory=/mnt /dev/sda Don\u0026rsquo;t forget to create a GRUB menu config file. Otherwise GRUB will boot into its command line interface (If you know what you\u0026rsquo;re doing). It\u0026rsquo;s a good idea to put a editable config file in the data partition since it will be the most used partition. However, GRUB reads the file in the EFI partition by default: (esp)/grub/grub.cfg. We can tell GRUB to read out custom config file after that.\n# (esp)/grub/grub.cfg search --set=root --file /boot.cfg configfile /boot.cfg Thus we are done with the EFI partition. All the menu configuration will go into boot.cfg in the data partition.\nLinux Installer Most of modern Linux distros support booting from a loop device. That is to say, we don\u0026rsquo;t have to extract the content of ISO files. Using GRUB loopback command can easily mount a ISO and boot from there. But chainloading the EFI or VBF is not possible. Based on the GRUB manual:\n GRUB is able to read from an image (be it one of CD or HDD) stored on any of its accessible storages (refer to see loopback command). However the OS itself should be able to find its root. This usually involves running a userspace program running before the real root is discovered.\n EFI bootloader usually will fail to find the root device by this method. However, we can manually load the kernel and ramdisk in which we can specify the root device by ourselves.\nLoad Linux ISO I\u0026rsquo;m using Arch Linux here for example.\n Put the ISO file to (data)/images/archlinux-2022.01.01-x86_64.iso. Mount ISO. We need to find the kernel loading parameters. In the file (arch)/syslinux/archiso_sys-linux.cfg we would see  # Copy to RAM boot option LABEL arch64ram TEXT HELP Boot the Arch Linux install medium on BIOS with Copy-to-RAM option It allows you to install Arch Linux or perform system maintenance. ENDTEXT MENU LABEL Arch Linux install medium (x86_64, BIOS, Copy to RAM) LINUX /arch/boot/x86_64/vmlinuz-linux INITRD /arch/boot/intel-ucode.img,/arch/boot/amd-ucode.img,/arch/boot/x86_64/initramfs-linux.img APPEND archisobasedir=arch archisolabel=ARCH_202201 copytoram This is a syslinux config file. Parameters after APPEND are the ones that we\u0026rsquo;re looking for.\nThen add the following content to (data)/boot.cfg. When copying the initrd parameters, don\u0026rsquo;t forget to remove commas.\nmenuentry \u0026quot;Archiso 202201 RAM\u0026quot; { search --set=root --file /boot.cfg loopback loop /images/archlinux-2022.01.01-x86_64.iso set root=(loop) linux /arch/boot/x86_64/vmlinuz-linux archisobasedir=arch archisolabel=ARCH_202201 copytoram initrd /arch/boot/intel-ucode.img /arch/boot/amd-ucode.img /arch/boot/x86_64/initramfs-linux.img } Then the Linux installer is done. If we need more distros, the process is similar.\nWindows Installer I prefer to use NTFS as my data partition\u0026rsquo;s file system because it works on both Linux and Windows, and supports big files. Also I usually just keep one copy of Windows installer so for Windows, I can simply dump the ISO content to the data partition\u0026rsquo;s root. I don\u0026rsquo;t mind the extra a few folders there. Plus some of them can be safely deleted. Then chainloading from GRUB is possible.\nIn (data)/boot.cfg\nmenuentry \u0026quot;Windows 10 Installer\u0026quot; { search --set=root --file /boot.cfg chainloader /efi/boot/bootx64.efi } Windows PE Alternatively, I can directly boot from a small WinPE image and use dism command to extract install.wim to the target without accepting the annoying Windows partition scheme (You know what I\u0026rsquo;m talking about).\nTo create a PE image we need a Windows environment and a CMD window with admin privilege.\nCreate a virtual disk to contain PE files. Assigned with volume letter P:\\.\n\u0026gt; diskpart DISKPART\u0026gt; create vdisk file=c:\\winpe.vhd maximum=2000 type=fixed DISKPART\u0026gt; select vdisk file=c:\\winpe.vhd DISKPART\u0026gt; attach vdisk DISKPART\u0026gt; convert mbr DISKPART\u0026gt; create partition primary DISKPART\u0026gt; format fs=ntfs quick DISKPART\u0026gt; assign letter=p DISKPART\u0026gt; exit Then mount the Windows installer ISO. Assuming the assigned volume is G:\\.\n\u0026gt; dism /apply-image /imagefile:g:\\sources\\boot.wim /index:1 /applydir:p:\\ \u0026gt; dism /image:p:\\ /set-targetpath:x:\\ \u0026gt; dism /image:p:\\ /set-inputlocale:en-us \u0026gt; dism /image:p:\\ /set-userlocale:en-us Assign EFI partition with volume letter E:\\.\nBefore creating the bootloader for Windows PE, we need to backup our GRUB EFI file (Windows PE bootloader will overwrite it). Rename E:\\EFI to E:\\EFI-grub.\nCreate Windows PE bootloader.\n\u0026gt; bcdboot p:\\Windows /l en-us /s e: /f uefi Then merge both E:\\EFI and E:\\EFI-grub. If it prompts overwriting E:\\EFI\\Boot\\bootx64.efi, confirm with yes.\nThen add following content to (data)/boot.cfg.\nmenuentry \u0026quot;Windows PE\u0026quot; { search --set=root --file /boot.cfg chainloader /EFI/Microsoft/Boot/bootmgfw.efi } Loading Any ISO Some ISO is capable to be loaded directly into memory. The size of the ISO file is critical. Generally it should not exceed the physical memory. This can be done by memdisk from syslinux.\nCopy the memdisk into the EFI partition.\n# cp /usr/lib/syslinux/bios/memdisk (esp)/memdisk Then put the following content to (data)/boot.cfg. For example, loading a Windows PE ISO.\nmenuentry \u0026quot;Windows PE ISO\u0026quot; { search --set=root --file /boot.cfg linux16 memdisk iso ro initrd16 /images/winpe.iso } The End Finally I\u0026rsquo;m very satisfied with this new USB drive. Yay!\n","date":"2022-01-26T20:34:18Z","permalink":"https://peromage.github.io/p/minimalists-multi-boot-usb-drive/","title":"Minimalist's Multi-boot USB Drive"},{"content":"YouTube has been pushing me a lot Emacs related contents. This is weird since mostly I watch Vim videos only. But probably this is also a great opportunity to try Emacs again.\nI have tried Emacs half year ago. I looked a lot Elisp programming fundamentals and tried a few Emacs configurations from others including Doom Emacs. However, it didn\u0026rsquo;t last long since I found that I didn\u0026rsquo;t have enough time to configure this Emacs setup as good as the Vim setup that I was using. Also using other\u0026rsquo;s configurations makes things become complicated for me. They have too many packages included and I don\u0026rsquo;t know what they are whether they are useful for me or not.\nAfter watching a bunch of Emacs videos I decided to pick it up this time, with vanilla Emacs starting from scratch. The reason why I make my mind this time is because I found Emacs can perfectly and elegantly solve some problems that pain my ass:\n More convenient package management. High quality packages. Easier file management in shell environment (Dired) No third party dependencies like Node.js and Python. The two major plugs that I\u0026rsquo;m using in Vim are Coc and Leaderf. They require Node.js and Python to work. Since Elisp is power enough, Emacs can handle this easily by itself. Server-client architecture. I can even replace Tmux with Emacs now. NeoVim has the similar concept but it cannot match what Emacs has. Graphical interface in X mode. This makes Emacs be able to display rich contents. Org mode. It looks great to organize to-do list and take notes without switching to other applications. Evil mode. No need to worry about missing Vim\u0026rsquo;s features. Magit. Looks way better and nicer than fugitive. Elisp Right. Elisp is fun ğŸ˜‰.  The migration is going slowly. Right now my main setup is still Vim + Tmux. There is a little curve learning from vanilla edition of Emacs, but It\u0026rsquo;s not a big deal compared with the first time when I started learning Vim ğŸ™‚.\nIn the end, dont\u0026rsquo;t give me wrong. Vim and Emacs both are great text editor. For me, Vim is more like a spirit, a concept. Once you\u0026rsquo;ve learned its high-efficiency key maps, you can use it everywhere. Even though I switch to Emacs I still use Vim mode together with Emacs' powerful extendability. Why not?\n","date":"2021-08-14T10:29:09-04:00","permalink":"https://peromage.github.io/p/moving-from-vim-to-emacs/","title":"Moving From Vim to Emacs"},{"content":"Background Previously I wrote a post for this dual-boot scenario. It is a little outdated. In the past year I mostly worked in the Linux environment on my old laptop, so the Windows seems not to be a necessity which occupies a dedicated partition. However, sometimes it is still needed. That is why I started thinking to improve this setup even further.\nStarting from Windows 7, Windows supports boots from a VHD file which makes it so much easier to manage. Also you are able to create differencing disks which are pretty much like snapshots.\nFor this new configuration, my plan is to use BIOS + GPT disk table + Native Linux + Native Windows booting from VHD + GRUB as the bootloader.\nPartitioning To make GPT works with BIOS. It is required to have a small partition flagged with EF02.\nThe partition scheme looks like this:\nDevice Start End Sectors Size Type /dev/sda1 34 2047 2014 1007K BIOS boot /dev/sda2 2048 1026047 1024000 500M EFI System /dev/sda3 1026048 206546943 205520896 98G Linux filesystem /dev/sda4 206546944 835692543 629145600 300G Linux filesystem /dev/sda5 835692544 1465149134 629456591 300.1G Microsoft basic data Installing Linux Any Linux distro would work. I chose Manjaro KDE this time because I found that the Pop OS made my laptop really hot sometimes (Yeah KDE is prettier).\nThis part should be easy. The GRUB files is going into that EFI partition. For details, check GRUB wiki.\nPreparing to Install Windows I\u0026rsquo;m not going to use the standard Windwos installer since I want to install it into a VHD file. To make it work we need a Windows PE environment.\nPreparing Images Any Windows PE (Windows 7 and above) would work. The PE ISO image is going to /boot/wepe.iso.\nAlso a Windows ISO image is needed. For example a Windows 7 ISO named windows7.iso will be put in the Windows data partition.\nAdding Windows PE to GRUB Boot into Linux. Download Windows PE ISO file and move it to the EFI partition (EXT4 partitions might be problematic).\nTo load this ISO image, memdisk tool from syslinux is required. Steps as below on Arch based distro:\n# Installing syslinux $ sudo pacman -S syslinux # Copying `memdisk` to the boot partition $ sudo cp /usr/lib/syslinux/bios/memdisk /boot/memdisk # Adding Windows PE entry to GRUB. 1DB1-9C31 is the boot partition\u0026#39;s UUID $ sudo cat \u0026lt;\u0026lt;EOF \u0026gt;\u0026gt;/etc/grub.d/40_custom menuentry \u0026#34;WePE x64\u0026#34; { search --set=root --no-floppy --fs-uuid 1DB1-9C31 linux16 /memdisk iso ro initrd16 /wepe.iso } EOF # Updating GRUB entries $ sudo grub-mkconfig -o /boot/grub/grub.cfg Installing Windows to a VHD File After adding Windows PE to the bootloader entries, it is time to switch the working environment.\nRestart the PC, then keep pression shift key until the GRUB menu shows up. Now navigate to the Windows PE entry and get in there.\nCreating a VHD File for Windows To create a VHD file, open a command line window and enter diskpart\n# Create a VHD file assuming the NTFS data partition is assigned with D: DISKPART\u0026gt; create vdisk file=d:\\windows7.vhd maximum=64000 type=fixed DISKPART\u0026gt; select vdisk file=d:\\windows7.vhd DISKPART\u0026gt; attach vdisk # Disk table type doesn\u0026#39;t matter but using MBR for better compatibility DISKPART\u0026gt; convert mbr # Create the system partition and assign it with C: DISKPART\u0026gt; create partition primary DISKPART\u0026gt; format fs=ntfs quick DISKPART\u0026gt; assign letter=c DISKPART\u0026gt; exit Now the Windows image can be dumped into this VHD file.\nExtracting Windows Image Mount the Windows ISO image to E: volume and open a command line window\n# Get the image index. For example the desired version\u0026#39;s index is 1 \u0026gt; dism /get-wiminfo /wimfile=e:\\sources\\install.wim # Extract the image. Where E: is the Windows ISO and C: is the VHD file \u0026gt; dism /apply-image /imagefile:e:\\sources\\install.wim /index:1 /applydir:c:\\ Fixing the Windows Bootloader Stay in Windows PE. Don\u0026rsquo;t restart the PC. We still need to fix the bootloader for Windows.\nNormally Windows cannot be booted with a GPT+MBR setup. And also loading the whole Windows VHD file through memdisk is not possible because it\u0026rsquo;s too large to load into memory. To fix the boot issue a bridge is needed between Windows and GRUB.\nLuckily a small VHD image can still be loaded by memdisk.\nThe idea is: GRUB -\u0026gt; MS Bootmgr VHD -\u0026gt; Windows VHD\nCreating a Dedicated Bootloader Image for Windows It is same with the process creating a VHD file for Windows system but this time it is a smaller file (32 MB).\n# Create a small bootmgr VHD file in the data partition DISKPART\u0026gt; create vdisk file=d:\\bootmgr.vhd maximum=32 type=fixed DISKPART\u0026gt; select vdisk file=d:\\bootmgr.vhd DISKPART\u0026gt; attach vdisk DISKPART\u0026gt; convert mbr DISKPART\u0026gt; create partition primary DISKPART\u0026gt; format fs=ntfs quick DISKPART\u0026gt; assign letter=f DISKPART\u0026gt; exit Now the bootmgr VHD is mounted at F:. Then write the boot record and create boot configuration files.\n\u0026gt; bootsect /nt60 f: /mbr \u0026gt; bcdboot c:\\Windows /l en-us /s f: /f bios Fixing the BCD Entry At this point it should be working according to the Microsoft\u0026rsquo;s document. In fact it is not.\nLet\u0026rsquo;s check the BCD entries, in a command window:\n\u0026gt; bcdedit /store f:\\Boot\\BCD /enum Windows Boot Manager -------------------- identifier {bootmgr} device partition=F: description Windows Boot Manager locale en-us inherit {globalsettings} default {default} resumeobject {fcd67427-e033-11eb-8826-cdf90e3873d0} displayorder {default} toolsdisplayorder {memdiag} timeout 30 Windows Boot Loader ------------------- identifier {default} device partition=C: path \\Windows\\system32\\winload.exe description Windows 7 locale en-us inherit {bootloadersettings} osdevice partition=C: systemroot \\Windows resumeobject {fcd67427-e033-11eb-8826-cdf90e3873d0} nx OptIn detecthal Yes The device and osdevice seems to be right but once the Windows VHD is unmounted it becomes unknown. According to this BCDEdit notes, BCD entry records the partition\u0026rsquo;s information such as UUID to find the correct partition during bootup. In this case the partition can\u0026rsquo;t be found until the VHD file is mounted. But this VHD file is not mounted automatically.\nThus we need to correct this and let Bootmgr locate the VHD file properly.\nIn a command line window:\n# The identifier must match the one which is showing above \u0026gt; bcdedit /store C:\\Boot\\BCD /set {default} device vhd=[D:]\\windows7.vhd \u0026gt; bcdedit /store C:\\Boot\\BCD /set {default} osdevice vhd=[D:]\\windows7.vhd If we check the BCD entry again it doesn\u0026rsquo;t change. But if we unmount the Windows VHD it will become:\n\u0026gt; bcdedit /store f:\\Boot\\BCD /enum Windows Boot Manager -------------------- identifier {bootmgr} device partition=E: description Windows Boot Manager locale en-us inherit {globalsettings} default {default} resumeobject {fcd67427-e033-11eb-8826-cdf90e3873d0} displayorder {default} toolsdisplayorder {memdiag} timeout 30 Windows Boot Loader ------------------- identifier {default} device vhd=[C:]\\windows7.vhd path \\Windows\\system32\\winload.exe description Windows 7 locale en-us inherit {bootloadersettings} osdevice vhd=[C:]\\windows7.vhd systemroot \\Windows resumeobject {fcd67427-e033-11eb-8826-cdf90e3873d0} nx OptIn detecthal Yes The volume letter doesn\u0026rsquo;t matter, it changes dynamically. Now bootmgr is able to locate the VHD file correctly.\nAdding Windows to GRUB Restart PC and get into Linux.\nModify the GRUB config file to load bootmgr\n# Adding Windows (bootmgr) entry to GRUB. 1DB1-9C31 is the boot partition\u0026#39;s UUID $ sudo cat \u0026lt;\u0026lt;EOF \u0026gt;\u0026gt;/etc/grub.d/40_custom menuentry \u0026#34;Windows 7\u0026#34; { search --set=root --no-floppy --fs-uuid 1DB1-9C31 linux16 /memdisk harddisk initrd16 /bootmgr.vhd } EOF # Updating GRUB entries $ sudo grub-mkconfig -o /boot/grub/grub.cfg Now we can restart PC. Keep pressing shift on bootup to go to the GRUB menu. Select Windows entry to boot Windows.\nFixing Windows Initialization Error During the first time bootup, Windows might have an error showing Windows could not complete the installation. To install Windows on this computer, restart the installation.\nTo solve this error:\n Press SHIFT + F10 to bring up the command prompt. Execute C:\\windows\\system32\\oobe\\msoobe. Wait for a while and the setup window will show up. Complete the setup and restart.  Creating a Differencing Disk A differencing disk can be used for quick recoveries.\nTo create it, restart into the Windows PE environment. In a command line window:\n# Use the original VHD as base \u0026gt; move d:\\windows7.vhd d:\\windows7_base.vhd # Create a differencing disk based on the original one # The name of the new differencing disk has to be the name that was recorded in the BCD \u0026gt; diskpart DISKPART\u0026gt; creat vdisk file=d:\\windows7.vhd parent=d:\\windows7_base.vhd Then all changes made in the future will go into the differencing disk. If system goes wrong one day, simply deleting the the differencing disk and creating a new one would quickly recover from the crysis.\nNOTE: After creating the differencing disk, the base VHD is not supposed to be modified.\nReferences  GRUB wiki BIOS + GPT + GRUB + Linux + Windows æŠ˜è…¾ç¬”è®° åœ¨ VHD ä¸­å®‰è£… Windows 7 Hack Bootmgr to boot Windows in BIOS to GPT Boot to a virtual hard disk: Add a VHDX or VHD to the boot menu BCDEdit notes 100% Solved:Windows could not complete the installation  ","date":"2021-07-09T16:40:31Z","permalink":"https://peromage.github.io/p/dual-booting-windows-vhd-and-native-linux-on-a-bios-gpt-pc/","title":"Dual-booting Windows VHD and Native Linux on a BIOS+GPT PC"},{"content":"å› ä¸ºæœ€è¿‘å¼„è‡ªå·±çš„åšå®¢ï¼Œæ¶‰åŠåˆ°äº†ç‰ˆæœ¬åº“åµŒå¥—çš„é—®é¢˜ã€‚è®°ä¸‹æ¥ä¹Ÿç®—æ˜¯ç»™è‡ªå·±ä¸€ä¸ªå¤‡å¿˜ã€‚\nä¸ºä»€ä¹ˆæœ‰è¿™æ ·çš„éœ€æ±‚ ç‰ˆæœ¬åº“åµŒå¥—å¾ˆå¥½ç†è§£ï¼Œå°±æ˜¯åœ¨ä¸€ä¸ª Git ä»“åº“é‡Œé¢åŒ…å«äº†å…¶ä»–çš„ Git ä»“åº“ã€‚é€šå¸¸æœ‰è¿™æ ·çš„éœ€æ±‚å¾€å¾€æ¶‰åŠåˆ°ååŒå¼€å‘ã€‚æ¯”å¦‚è¿™é‡Œæœ‰ä¸€ä¸ªæ’ä»¶å•ç‹¬çš„ Git ä»“åº“å§‘ä¸”å«â€œPluginâ€ã€‚ç°åœ¨æˆ‘åˆ›å»ºäº†ä¸€ä¸ªè‡ªå·±çš„é¡¹ç›®ï¼Œå…¶ä¸­éœ€è¦ç”¨åˆ°è¿™ä¸ªâ€œPluginâ€æ’ä»¶ã€‚é€šå¸¸æ¯”è¾ƒç¬¨çš„åŠæ³•å°±æ˜¯æŠŠæ’ä»¶åº“æºç æ‹–ä¸‹æ¥ï¼Œå¤åˆ¶åˆ°è‡ªå·±çš„é¡¹ç›®é‡Œã€‚ä½†æ˜¯è¿™æ ·å½“æ’ä»¶åº“æ›´æ–°çš„æ—¶å€™ï¼Œæ’ä»¶æºç æ›´æ–°å¾€å¾€æ¯”è¾ƒéº»çƒ¦ã€‚è€Œä¸”å¦‚æœåœ¨ä½¿ç”¨çš„è¿‡ç¨‹ä¸­ä¿®æ”¹äº†æ’ä»¶çš„æºç ï¼Œä¹Ÿä¸ä¾¿äºæ’ä»¶å•ç‹¬çš„ç‰ˆæœ¬æ§åˆ¶ï¼Œæ›´åˆ«è¯´ä¸ºæ’ä»¶åº“è´¡çŒ®ä»£ç äº†ã€‚ä½†å¦‚æœæ’ä»¶å•ç‹¬ä»¥ Git ä»“åº“å­˜åœ¨äºæˆ‘çš„é¡¹ç›®ç›®å½•ä¸­ï¼Œä»¥ä¸Šçš„é—®é¢˜å°±è§£å†³äº†ã€‚\nåœ¨ Git é‡Œé¢æä¾›äº†ä¸¤ç§æ–¹å¼å®ç°ä¸Šè¿°éœ€æ±‚ï¼Œé‚£å°±æ˜¯ Subtree å’Œ Submoduleã€‚\nSubmodule Submodule æ˜¯ Git é‡Œé¢æœ€æ—©æä¾›çš„ä¸€ç§æ–¹æ³•ã€‚é¡¾åæ€ä¹‰â€œå­æ¨¡å—â€ã€‚\næ·»åŠ å­æ¨¡å— æ‰§è¡Œ\ngit submodule add \u0026lt;repo\u0026gt; \u0026lt;module_path\u0026gt;\næ­¤æ—¶è¿è¡Œ git status å¯ä»¥çœ‹åˆ°å­æ¨¡å—å¯¹åº”çš„æ–‡ä»¶å¤¹å’Œä¸€ä¸ªå«åš .gitmodules æ–‡ä»¶è¢«æ·»åŠ è¿›äº†æš‚å­˜åŒºã€‚å…¶ä¸­*.gitmodules*æ˜¯ç”¨äºè®°å½•å­æ¨¡å—ç›¸å…³ä¿¡æ¯çš„ã€‚ä¹‹åä¸»é¡¹ç›®é‡Œé¢çš„æ“ä½œç…§å¸¸æäº¤å°±å¯ä»¥äº†ã€‚\nä¿®æ”¹å­æ¨¡å— ä½†å¦‚æœåœ¨å¼€å‘çš„é€”ä¸­ä¿®æ”¹äº†å­æ¨¡å—çš„ä»£ç ï¼Œéœ€è¦å•ç‹¬åˆ°å­æ¨¡å—å¯¹åº”çš„æ ¹ç›®å½•é‡Œé¢è¿›è¡Œå­æ¨¡å—å•ç‹¬çš„æäº¤æ“ä½œã€‚åœ¨ä¸»é¡¹ç›®é‡Œé¢è™½ç„¶å¯ä»¥çœ‹åˆ°å­æ¨¡å—æœ‰å˜æ›´ï¼Œä½†æ˜¯æ— æ³•çœ‹åˆ°å…·ä½“çš„æ›´æ”¹æ“ä½œï¼Œè€Œæ˜¯å°†å…¶çœ‹ä½œä¸€ä¸ªæ¨¡å—æ•´ä½“ã€‚ä¸€æ—¦å­æ¨¡å—äº§ç”Ÿäº†æ–°çš„æäº¤ï¼Œä¸»é¡¹ç›®é‡Œé¢å¯ä»¥çœ‹åˆ°å­æ¨¡å—çš„ HEAD å˜åŒ–ï¼Œä»è€Œä¸»é¡¹ç›®ä¹Ÿåº”å½“äº§ç”Ÿä¸€ä¸ªæ–°çš„æäº¤ä»¥è®°å½•å¯¹åº”å…³ç³»ã€‚\næ¢å¥è¯è¯´ï¼Œä¸»é¡¹ç›®å°±æ˜¯é ç€è®°å½•å­æ¨¡å— HEAD å€¼æ¥åˆ¤æ–­ä¾èµ–çš„ã€‚å­æ¨¡å—çš„ä»£ç æœ€åå°†ä¸ä¼šè¿›å…¥ä¸»é¡¹ç›®çš„ç‰ˆæœ¬åº“é‡Œé¢ï¼ˆåªæœ‰ HEAD å€¼ï¼‰\nç°åœ¨å­æ¨¡å—æœ‰äº†æ–°çš„æäº¤ï¼Œä¸ºäº†å°†æœåŠ¡å™¨ä¸Šçš„ä»£ç æ›´æ–°ï¼Œæˆ‘ä»¬åªéœ€è¦è¿›å…¥å­æ¨¡å—å¯¹åº”çš„æ›´ç›®å½•æ‰§è¡Œ push æ“ä½œå°±å¯ä»¥äº†ã€‚\næ›´æ–°å­æ¨¡å— æ­¤æ—¶å­æ¨¡å—ä¸Šæ¸¸æœ‰äº†æ–°çš„ä»£ç ï¼Œæˆ‘ä»¬éœ€è¦å°†å…¶æ•´åˆåˆ°å½“å‰çš„é¡¹ç›®ä¸­ã€‚æœ‰ä¸¤ç§æ–¹æ³•ã€‚\nåœ¨ä¸»é¡¹ç›®æ ¹ç›®å½•ä¸‹è¿è¡Œ\ngit submodule foreach git pull\næˆ–è€…åˆ‡æ¢åˆ°å­æ¨¡å—çš„æ ¹ç›®å½•ä¸‹é¢ git pull\nå…‹éš†é¡¹ç›® å…‹éš†ä¸»é¡¹ç›®çš„æ—¶å€™å­æ¨¡å—å¹¶ä¸ä¼šæ‹‰å–åˆ°æœ¬åœ°ï¼Œå¦‚æœè¿›å…¥å¯¹åº”çš„ç›®å½•ä¼šå‘ç°æ˜¯ç©ºçš„ã€‚\næ­¤æ—¶åº”å½“\ngit submodule init\nä¿æŒæœ€æ–°\ngit submodule update\næˆ–è€…å¯ä»¥ç›´æ¥ä¸€æ¡å‘½ä»¤æå®š\ngit clone --recursive \u0026lt;repo\u0026gt;\nåˆ é™¤å­æ¨¡å— Git ä¸­æ²¡æœ‰æä¾›ç›´æ¥åˆ é™¤çš„å‘½ä»¤ï¼Œéœ€è¦æ‰‹åŠ¨å®Œæˆåˆ é™¤æ“ä½œã€‚\nåå‘åˆå§‹åŒ–å­æ¨¡å—\ngit submodule deinit --force \u0026lt;module_path\u0026gt;\næˆ–è€…ç›´æ¥åˆ æ‰ .git/config é‡Œç›¸å…³ä¿¡æ¯\nç§»é™¤å­æ¨¡å—\ngit rm \u0026lt;module_path\u0026gt;\nå¦‚æœæš‚å­˜åŒºè¿˜æœ‰ git rm --cached \u0026lt;module_path\u0026gt;\nå­æ¨¡å—çš„å‘ æäº¤çš„å‘ å‡è®¾æœ‰ A B ä¸¤ä¸ªäººåŒæ—¶åœ¨å¼€å‘ä¸€ä¸ªé¡¹ç›®ï¼Œè¿™ä¸ªé¡¹ç›®é‡Œé¢ä¹ŸåŒ…å«äº†ä¸€ä¸ªå­æ¨¡å—ã€‚æ­¤æ—¶ A ä¿®æ”¹äº†ä¸šåŠ¡ä»£ç ï¼ŒåŒæ—¶ä¿®æ”¹äº†ä¸€ä¸ªå­æ¨¡å—é‡Œé¢çš„ä¸€ä¸ª bug ã€‚A å°†è¿™æ¬¡ä¿®æ”¹æäº¤ï¼Œä¸»é¡¹ç›®çš„æäº¤é‡Œé¢æŒ‡å‘äº†å­æ¨¡å—æ–°çš„ HEAD1 ï¼Œç„¶åæŠŠä¸»é¡¹ç›®çš„ç‰ˆæœ¬åº“ push åˆ°äº†æœåŠ¡å™¨ï¼Œä½†æ˜¯æ²¡æœ‰ push å­æ¨¡å—ã€‚B æ­¤æ—¶ pull äº†ä¸»é¡¹ç›®ï¼Œç„¶å update å­æ¨¡å—ï¼Œè¢«å‘ŠçŸ¥æ‰¾ä¸åˆ°å­æ¨¡å—çš„ HEAD1 ã€‚å› ä¸ºæŒ‡å‘ HEAD1 çš„æäº¤è¿˜åœ¨ A æœ¬åœ°æœºå™¨ä¸Šã€‚\nè¿™å°±æ˜¯å­æ¨¡å—æäº¤çš„å‘ã€‚åœ¨å¤šä¸ªæ¨¡å—å­˜åœ¨çš„æ—¶å€™æ“ä½œéå¸¸ç¹çã€‚\nåˆå§‹åŒ–çš„å‘ åœ¨æ‰§è¡Œ git submodule initï¼Œ git submodule update ä¹‹åï¼Œæ­¤æ—¶ä¿®æ”¹å­æ¨¡å—å¯èƒ½å‡ºç° HEAD å¤„äºæ¸¸ç¦»çŠ¶æ€çš„çš„æç¤ºã€‚å¦‚æœä¸æ³¨æ„ææœ‰å¯èƒ½å‡ºç°ä¸¢å¤±æäº¤çš„å¯èƒ½ã€‚\nè§£å†³åŠæ³•ï¼Œåœ¨ä»¥ä¸Šä¸¤æ¡å‘½ä»¤ä¹‹åæ‰§è¡Œä¸€æ¬¡æ£€å‡º\ngit checkout \u0026lt;branch\u0026gt;\nSubtree æ·»åŠ å­é¡¹ç›® é¦–å…ˆæ·»åŠ å­é¡¹ç›®å¯¹åº”çš„è¿œç¨‹æœåŠ¡å™¨\ngit remote add \u0026lt;subrepo_name\u0026gt; \u0026lt;subrepo_remote\u0026gt;\næ‹‰å–ä¸€ä¸‹\ngit fetch \u0026lt;subrepo_name\u0026gt;\næ·»åŠ å­é¡¹ç›®åˆ°çˆ¶é¡¹ç›®é‡Œé¢\ngit subtree add --squash --prefix=\u0026lt;subrepo_path\u0026gt; \u0026lt;subrepo_name\u0026gt; \u0026lt;branch\u0026gt;\nå‚æ•° \u0026ndash;squash ä½œç”¨åœ¨äºåˆå¹¶å­é¡¹ç›®æ‰€æœ‰æäº¤ä¸ºä¸€ä¸ªï¼Œå¹¶ merge åˆ°çˆ¶é¡¹ç›®çš„å†å²ä¸­ï¼Œè¿™æ ·åªä¼šå‡ºç°ä¸¤ä¸ªæäº¤è®°å½•ï¼Œé¿å…å­é¡¹ç›®çš„æäº¤å†å²æ±¡æŸ“çˆ¶é¡¹ç›®ã€‚æ›´å¤šè®¨è®ºå¯ä»¥çœ‹è¿™é‡Œã€‚\nä¿®æ”¹å­é¡¹ç›® æ·»åŠ å®Œæ¯•ä¹‹åç…§å¸¸ä¿®æ”¹æäº¤å„ç§æ“ä½œï¼Œçˆ¶é¡¹ç›®èƒ½å¤Ÿè·Ÿè¸ªå­é¡¹ç›®é‡Œé¢çš„æ‰€æœ‰å˜æ›´ã€‚å­é¡¹ç›®è¢«å½“åšä¸€ä¸ªæ­£å¸¸çš„å­æ–‡ä»¶å¤¹å¤„ç†ã€‚\nå¦‚æœç°åœ¨ä¿®æ”¹äº†å­é¡¹ç›®é‡Œçš„ä¸€ä¸ª bug å¹¶ä¸”æƒ³è¦åé¦ˆç»™ä¸Šæ¸¸ï¼Œå¯ä»¥è¿™æ ·æ“ä½œ\ngit subtree push --prefix=\u0026lt;subrepo_path\u0026gt; \u0026lt;subrepo_name\u0026gt; \u0026lt;bug_fixed\u0026gt;\nè¿™ä¸ªæ“ä½œå¯ä»¥å°†çˆ¶é¡¹ç›®é‡Œæ‰€æœ‰æ¶‰åŠå­é¡¹ç›®ä¿®æ”¹çš„æäº¤æ£€å‡ºã€‚è¿™æ ·åœ¨è¿œç¨‹ä»“åº“é‡Œé¢ä¼šå‡ºç°ä¸€ä¸ªå«åš bug_fixed çš„åˆ†æ”¯ã€‚\næˆ–è€…ä¹Ÿå¯ä»¥è¿™æ ·æ“ä½œ\ngit subtree split --prefix=\u0026lt;subrepo_path\u0026gt; --branch \u0026lt;new_branch_name\u0026gt;\nè¿™ä¸ªæ“ä½œè·Ÿä¸Šé¢ä¸€æ ·å°†çˆ¶é¡¹ç›®é‡Œæ‰€æœ‰æ¶‰åŠå­é¡¹ç›®ä¿®æ”¹çš„æäº¤æ£€å‡ºï¼Œå¹¶ä¸”æŠŠå­é¡¹ç›®çš„æ ¹æ–‡ä»¶å¤¹è®¾ä¸ºæ•´ä¸ªé¡¹ç›®çš„æ ¹æ–‡ä»¶å¤¹ï¼Œç„¶åæ£€å‡ºä¸ºçˆ¶é¡¹ç›®çš„ä¸€ä¸ªæ–°çš„åˆ†æ”¯ã€‚\nç„¶åæ¨é€ç»™ä¸Šæ¸¸\ngit push \u0026lt;subrepo_remote\u0026gt; \u0026lt;new_branch_name\u0026gt;:\u0026lt;bug_fixed\u0026gt;\nä¹‹ååˆ é™¤å¯¹åº”æœ¬åœ°åˆ†æ”¯å°±å¯ä»¥äº†ã€‚\næ›´æ–°å­é¡¹ç›® æ‹‰å–éå¸¸æ–¹ä¾¿\ngit subtree pull --prefix=\u0026lt;subrepo_path\u0026gt; \u0026lt;subrepo_name\u0026gt; \u0026lt;branch\u0026gt;\nåˆ é™¤å­é¡¹ç›® å› ä¸ºå­é¡¹ç›®åœ¨çˆ¶é¡¹ç›®é‡Œé¢å°±æ˜¯è¢«å½“åšä¸€ä¸ªæ™®é€šçš„æ–‡ä»¶å¤¹å¤„ç†çš„ï¼Œæ‰€ä»¥ç›´æ¥ç§»é™¤æ–‡ä»¶å¤¹å¹¶æäº¤å°±å¯ä»¥äº†ã€‚\nSubmodule vs. Subtree Git å®˜æ–¹æ¨èä½¿ç”¨æ–°çš„ Subtree ï¼Œäº‹å®è¯æ˜çš„ç¡®æ¯” Submodule æ–¹ä¾¿ä¸å°‘ã€‚Subtree ä¸ä¼šäº§ç”Ÿé¢å¤–çš„æ–‡ä»¶ï¼Œè€Œä¸”å­é¡¹ç›®çš„ä»£ç åŒ…å«åœ¨çˆ¶é¡¹ç›®é‡Œé¢ï¼Œä¸ä¼šå‡ºç°å‰é¢æåˆ°çš„å‘çš„é—®é¢˜ã€‚å…·ä½“åº”ç”¨ä¸Šçš„å¯¹æ¯”å¯ä»¥å‚è€ƒè¿™ç¯‡æ–‡ç« ã€‚Subtree å¯¹äºä»£ç è¿­ä»£è¾ƒå¿«çš„é¡¹ç›®å°¤ä¸ºé€‚åˆã€‚\nä½†ä¹Ÿä¸æ˜¯è¯´ Submodule ä¸€æ— æ˜¯å¤„ï¼Œ Submodule åœ¨æˆ‘æ„Ÿè§‰æœ€å¤§çš„æ„ä¹‰åœ¨äºå¯ä»¥éš”ç¦»å­é¡¹ç›®çš„ä¸šåŠ¡ä»£ç ï¼Œå¹¶ä¸”è®°å½•ä¸¥æ ¼çš„ä¾èµ–å…³ç³»ã€‚å¯¹äºä¸€äº›å­æ¨¡å—æ›´æ–°è¾ƒæ…¢çš„é¡¹ç›®è¿˜æ˜¯æ¯”è¾ƒé€‚åˆçš„ã€‚\n","date":"2017-04-07T20:53:53Z","permalink":"https://peromage.github.io/p/git-%E4%B8%AD%E7%9A%84-subtree-%E5%92%8C-submodule/","title":"Git ä¸­çš„ Subtree å’Œ Submodule"},{"content":"0x00 æƒ…å†µç®€è¿° ç”±äºå¼€å‘éœ€è¦ Linux ç¯å¢ƒï¼Œæ‰€ä»¥å°†è€çš„é‚£å°ç¬”è®°æœ¬æ”¹é€ æˆäº†åŒç³»ç»Ÿã€‚\nè¿™å°ç”µè„‘çš„åŸºæœ¬æƒ…å†µæ˜¯è¿™æ ·çš„ï¼Œ64GB å›ºæ€ç¡¬ç›˜ + 720GB æœºæ¢°ç¡¬ç›˜ï¼ˆå®é™…å¯ç”¨ç©ºé—´æœ‰æŠ˜æŸï¼Œè¿™é‡Œä¸ºäº†è¡¨ç¤ºæ–¹ä¾¿ï¼‰ï¼ŒWindows 10 å·²ç»å®‰è£…åˆ°äº†å›ºæ€ç¡¬ç›˜ä¸Šã€‚ç”±äºä¸»æ¿è¾ƒè€ï¼Œåªèƒ½æ”¯æŒ BIOSã€‚å·¨ç¡¬åˆè¯´è¿‡ Windows åªèƒ½æ”¯æŒ BIOS + MBRï¼Œæ‰€ä»¥ç¬¬ä¸€å—ä¸»ä½ï¼ˆMasterï¼‰ä¸Šçš„å›ºæ€ç¡¬ç›˜å°±åªèƒ½é‡‡ç”¨ MBR åˆ†åŒºè¡¨ï¼Œåˆ†æˆäº†ä¸¤ä¸ªåŒºï¼Œ500MB ç”¨ä½œå¯åŠ¨åˆ†åŒºï¼Œå‰©ä¸‹çš„éƒ¨åˆ†å…¨éƒ¨åˆ’ç»™äº†ç³»ç»Ÿåˆ†åŒºã€‚\nä½†æ˜¯ Linux è¡¨ç¤ºæ²¡æœ‰å·¨ç¡¬è¿™ç§å°¿æ€§ï¼Œæ‰€ä»¥ä¸ºä»€ä¹ˆä¸ä½¿ç”¨æ›´å…ˆè¿›çš„ GPT åˆ†åŒºè¡¨ï¼Ÿå› æ­¤ä»ä½ï¼ˆSlaveï¼‰ä¸Šçš„æœºæ¢°ç¡¬ç›˜è¢«æˆ‘åˆ†æˆäº†è¿™ä¸ªæ ·å­ï¼š\n10MB BIOS å¯åŠ¨åˆ†åŒºï¼ˆNo File Systemï¼‰ + 500MB /boot å¯åŠ¨æŒ‚è½½ç‚¹ï¼ˆEXT4ï¼‰ + 100GB / æ ¹æŒ‚è½½ç‚¹ï¼ˆEXT4ï¼‰ + 199.5GB /home ç”¨æˆ·ç›®å½•æŒ‚è½½ç‚¹ï¼ˆEXT4ï¼‰ + 420GB Windows æ•°æ®åˆ†åŒºï¼ˆNTFSï¼‰ã€‚\nBIOS å¯åŠ¨åˆ†åŒº 1MB è¶³ä»¥ï¼Œæˆ‘åªæ˜¯è€ƒè™‘åˆ°åç»­æ‰©å±•é—®é¢˜ã€‚ä¹‹ååœ¨ç¬¬äºŒå—ç¡¬ç›˜ä¸Šå®‰è£…äº† Arch Linuxã€‚\n0x01 æœ‰å•¥å¥½æŠ˜è…¾çš„ï¼Ÿ åŒç³»ç»Ÿå®‰è£…å¥½ä»¥åç›¸å®‰æ— äº‹ï¼ŒBIOS é»˜è®¤ä»ä¸»ä½å›ºæ€ç¡¬ç›˜å¯åŠ¨ã€‚ä¹Ÿå°±æ˜¯è¯´å¼€æœºä¸è¿›è¡Œä»»ä½•æ“ä½œçš„è¯ï¼Œé»˜è®¤è¿›å…¥çš„æ˜¯ Windows 10ã€‚åªæœ‰åœ¨å¼€æœºçš„æ—¶å€™ä½¿ç”¨ BIOS çš„ Fast Boot åŠŸèƒ½ï¼Œé€‰æ‹©ä»ç¬¬äºŒå—ç¡¬ç›˜å¯åŠ¨æ‰èƒ½è¿›å…¥ Arch Linuxã€‚æ¢å¥è¯è¯´ä¸¤ä¸ªç³»ç»Ÿå½¼æ­¤éƒ½æ˜¯é€æ˜çš„ã€‚ ä½†æ˜¯ä½œä¸ºä¸€ä¸ªå¼ºè¿«ç—‡å’Œå®Œç¾ä¸»ä¹‰è€…ï¼Œä¸‡ä¸€æˆ‘æƒ³è¿›å…¥ Linuxï¼Œä½†æ˜¯å¼€æœºçš„æ—¶å€™é”™è¿‡äº†ï¼Œå²‚ä¸æ˜¯è¦é‡å¯ä¸€æ¬¡æ‰è¡Œï¼Ÿæˆ–è€…ä¸‡ä¸€æˆ‘åˆåæ‚”æƒ³è¿›å…¥ Windows åˆè¦é‡å¯ä¸€æ¬¡ï¼Ÿè¿™æ€ä¹ˆèƒ½å¿ï¼Œæ‰€ä»¥æ‰æœ‰äº†è¿™æ¬¡çš„æŠ˜è…¾â€¦â€¦\n0x02 åœ¨ GRUB ä¸­æ·»åŠ å¼•å¯¼èœå• å¯¹äº GRUB ï¼ˆæ³¨ï¼šè¿™é‡Œæ‰€è¯´çš„ GRUB æŒ‡çš„æ˜¯ GRUB 2 è€Œä¸æ˜¯ GRUB Legacyï¼‰ å¼•å¯¼çš„ Linux æ¥è¯´ï¼Œåˆ‡æ¢åˆ° Windows çš„ bootmgr æ˜¯ä¸€ä»¶å¾ˆå®¹æ˜“çš„äº‹æƒ…ï¼Œæœ€æ–°ç‰ˆçš„ GRUB å¯ä»¥ç›´æ¥å¯åŠ¨ bootmgr è€Œä¸éœ€è¦ä¹‹å‰çš„ chainloading æ¨¡å¼ã€‚ è¿›å…¥ Arch Linuxï¼Œä»¥ root æƒé™ç¼–è¾‘ /etc/grub.d/40_custom ï¼ŒåŠ å…¥ä»¥ä¸‹èœå•ï¼š\nmenuentry \u0026quot;Switch to Microsoft Boot Manager\u0026quot; { insmod part_msdos insmod ntfs insmod search_fs_uuid insmod ntldr search --fs-uuid --set=root 69B235F6749E84CE ntldr /bootmgr } insmod æ˜¯ç”¨äºåŠ è½½å¿…è¦çš„æ¨¡å—ä»¥ä¾¿ GRUB è¯†åˆ«å¹¶æ­£ç¡®å¯åŠ¨ Windowsã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œsearch ä¸€è¡ŒæŒ‡å®šçš„ UUID ä¸ Linux ä¸‹ lsblk -f çœ‹åˆ°çš„ UUID æ˜¯ä¸ä¸€æ ·çš„ï¼Œéœ€è¦ä½¿ç”¨ sudo grub-probe --target=fs_uuid -d /dev/sda1 æ¥è·å– GRUB ä¸‹å¯¹åº”çš„åˆ†åŒº UUIDã€‚è¿™ä¸ªä¾‹å­ä¸­ï¼ŒWindows å¯åŠ¨åˆ†åŒºæ˜¯ sda1ã€‚UUID æ˜¯å”¯ä¸€çš„ï¼Œå‹¿ç…§æ¬ã€‚\nå½“ç„¶ä¹Ÿå¯ä»¥ä½¿ç”¨ä¼ ç»Ÿçš„ chainloading æ¨¡å¼ï¼š\nmenuentry \u0026quot;Switch to Microsoft Boot Manager\u0026quot; { insmod part_msdos insmod ntfs insmod search_fs_uuid search --fs-uuid --set=root 69B235F6749E84CE chainloader +1 } ä¿å­˜ä»¥åï¼Œæ‰§è¡Œ sudo grub-mkconfig -o /boot/grub/grub.cfg ï¼Œä»¥ä¾¿æ›´æ–°å¯åŠ¨èœå•ã€‚\nä¸æ¨èç›´æ¥ç¼–è¾‘ /boot/grub/grub.cfgï¼Œå› ä¸ºä¸Šè¿°å‘½ä»¤ä¼šè¦†ç›–è¿™ä¸ªæ–‡ä»¶ï¼Œä¸ä¾¿äºè‡ªå®šä¹‰èœå•çš„ç®¡ç†ã€‚\nè¿™æ ·å°±å¯ä»¥ç›´æ¥è·³è½¬åˆ° bootmgrï¼Œè®©å®ƒå»å¯åŠ¨ Windowsã€‚\n0x03 BCD å¯»æ€ BCD æ˜¯Windows Vista ä¹‹åä½¿ç”¨çš„ä¸€ç§å¯åŠ¨ç®¡ç†å™¨ã€‚æœ‰ä¸ªéå¸¸è›‹ç–¼çš„é—®é¢˜å°±åœ¨äºï¼ŒBCD å¹¶ä¸æ”¯æŒ EXT4 åˆ†åŒºæ ¼å¼ï¼Œæ‰€ä»¥æ²¡æœ‰åŠæ³•è¯»åˆ° GRUBã€‚æŸ¥é˜…äº†ç›¸å…³èµ„æ–™ï¼Œç»™å‡ºçš„è§£å†³åŠæ³•å°±æ˜¯ï¼Œå°† /boot åˆ†åŒºæ ¼å¼åŒ–æˆ FAT32 çš„æ–‡ä»¶ç³»ç»Ÿã€‚éš¾é“æˆ‘è¿˜å¾—å†æŠ˜è…¾ä¸€æ¬¡æ–‡ä»¶ç³»ç»Ÿï¼Ÿç›´è§‰å‘Šè¯‰æˆ‘ä¸€å®šè¿˜æœ‰å…¶ä»–çš„åŠæ³•ã€‚\næ—¢ç„¶ BCD æ²¡åŠæ³•ç›´æ¥è¯» EXT4 åˆ†åŒºé‡Œé¢çš„ä¸œè¥¿ï¼Œæˆ‘ä»¬å¯ä»¥æ›²çº¿æ•‘å›½ã€‚BCD é‡Œé¢æä¾›äº†ä¸€ç§å®æ¨¡å¼å¯åŠ¨çš„æ–¹å¼ï¼Œå…è®¸è¯»å–ä¸€ä¸ªåŒ…å«äº†å¯åŠ¨ä»£ç çš„æ–‡ä»¶ã€‚æ‰€ä»¥ä¸€ç§è§£å†³åŠæ³•å°±æ˜¯ BCD â†’ MBR â†’ VBR â†’ Bootloaderã€‚ç”±äº GPT ç£ç›˜çš„ç¬¬ä¸€ä¸ªæ‰‡åŒºè¢«åˆ’åˆ†æˆäº† Protective MBRï¼Œç”¨äºå…¼å®¹ BIOSï¼Œæ‰€ä»¥åœ¨ Linux ä½¿ç”¨ï¼š\nsudo dd if=/dev/sdb of=/mnt/reserved/grub.bin bs=512 count=1\nå¯ä»¥å°†ç¬¬äºŒå—ç¡¬ç›˜çš„ç¬¬ä¸€æ‰‡åŒºé‡Œé¢çš„å¯åŠ¨ä»£ç å¯¼å‡ºåˆ°ä¸€ä¸ªæ–‡ä»¶ï¼Œç„¶åä½¿ç”¨ BCD åŠ è½½è¿™ä¸ªæ–‡ä»¶å°±å¯ä»¥å¯åŠ¨ GRUBäº†ã€‚\næœçœŸå¦‚æ­¤ï¼Ÿ\näº‹å®æ˜¯ï¼Œè¿™ç§æ–¹æ³•å¯è¡Œï¼Œä½†æ˜¯å¹¶ä¸é€‚ç”¨æˆ‘çš„æƒ…å†µï¼Œå› ä¸ºè¿™æ˜¯å»ºç«‹åœ¨ Windows å’Œ Linux å®‰è£…åœ¨åŒä¸€å—ç¡¬ç›˜ä¸Šçš„æƒ…å½¢ã€‚grub.bin å¹¶ä¸èƒ½å¤Ÿè·¨åˆ†åŒºå¯»æ‰¾ VBRã€‚éš¾é“åªèƒ½ä½œç½¢ï¼Ÿè‚¯å®šä¸å¯èƒ½ï¼Œä¸ç„¶å°±æ²¡æœ‰è¿™ç¯‡æ–‡ç« äº†ã€‚\næŸ¥é˜…äº†è‹¥å¹²æ–‡æ¡£ä¹‹åï¼Œå¾—çŸ¥ GRUB æä¾›äº†ä¸€ä¸ª å«åš lnxboot.img æ–‡ä»¶ï¼Œå¯ä»¥å°† GRUB å¯åŠ¨é˜¶æ®µæ¨¡æ‹Ÿæˆä¸€ä¸ªå¯ä»¥å¯åŠ¨çš„ Linux å†…æ ¸ï¼Œç„¶åæŒ‚è½½ core.img é‡Œé¢å¿…è¦çš„æ¨¡å—ï¼Œä»è€Œé¡ºåˆ©å¯åŠ¨ GRUBã€‚é‚£ä¹ˆå°†ä¹‹å‰çš„æ€è·¯ä¿®æ”¹æˆ BCD â†’ VBR â†’ Bootloader å°±è¡Œäº†ï¼Œå³æ—¢ç„¶ MBR ä¸èƒ½è·¨åˆ†åŒºä»¥åŠè¯†åˆ« GPTï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æ¢æˆä¸€ä¸ªå¯ä»¥èƒœä»»çš„ä¸å°±è¡Œäº†ã€‚\n0x04 åˆ¶ä½œå¯åŠ¨é•œåƒ è¿›å…¥ Arch Linuxã€‚è™½ç„¶åœ¨ /boot/grub/i386-pc/ ç›®å½•ä¸‹æœ‰ä¸€ä¸ªç”¨äºå¯åŠ¨çš„ core.img æ–‡ä»¶ï¼Œè¿™ä¸ªæ–‡ä»¶é‡Œé¢æŒ‡å®šçš„æ¨¡å—è·¯å¾„æ˜¯ç›¸å¯¹è·¯å¾„ï¼Œä½¿ç”¨å®ƒå¯åŠ¨ä¾ç„¶ä¼šæ˜¾ç¤ºé”™è¯¯ï¼Œéœ€è¦æŒ‡å®šç»å¯¹è·¯å¾„ä»¥ä¿è¯ä¸‡æ— ä¸€å¤±ã€‚é‚£ä¹ˆæˆ‘ä»¬å°±æ¥æ‰‹åŠ¨ç”Ÿæˆä¸€ä¸ªï¼Œé¡ºä¾¿é›†æˆä¸€äº›æˆ‘ä»¬éœ€è¦çš„æ¨¡å—ã€‚\næ³¨æ„ï¼Œå¯åŠ¨é•œåƒç¨åä¼šè¢«æ”¾åœ¨ Windows çš„å¯åŠ¨åˆ†åŒºä¸‹é¢ï¼ˆBCD çš„å¯åŠ¨åˆ†åŒºï¼‰ï¼Œæ‰€ä»¥è¿˜éœ€è¦çŸ¥é“æ¨¡å—æ‰€åœ¨åˆ†åŒºçš„ä½ç½®ã€‚åœ¨ GRUB ä¸­è¡¨ç¤ºç£ç›˜çš„æ–¹å¼æœ‰æ‰€ä¸åŒï¼Œå¦‚ (hd0,msdos1) è¡¨ç¤ºç¬¬ä¸€å—ç£ç›˜ï¼Œä½¿ç”¨ MBR åˆ†åŒºè¡¨ï¼Œç¬¬ä¸€ä¸ªåˆ†åŒºï¼› (hd1,gpt2) è¡¨ç¤ºç¬¬äºŒå—ç£ç›˜ï¼Œä½¿ç”¨ GPTåˆ†åŒºè¡¨ï¼Œç¬¬äºŒä¸ªåˆ†åŒºã€‚æ‹¬å·ä¸å¯çœï¼Œç£ç›˜å’Œåˆ†åŒºçš„èµ·å§‹æ•°å­—ä¸ä¸€æ ·ã€‚\nä½¿ç”¨ grub-probe æ¥è·å– /boot åˆ†åŒºä¿¡æ¯ã€‚è¿™ä¸ªä¾‹å­å¾—åˆ°çš„æ˜¯ hd1,gpt2ï¼š\nsudo grub-probe --target=bios_hints /boot\nç”Ÿæˆ core.imgï¼š\nsudo grub-mkimage --output=/tmp/core.img --prefix=\\(hd1,gpt2\\)/grub --format=i386-pc biosdisk part_msdos part_gpt ext2\næ³¨æ„åƒæˆ‘è¿™æ · /boot å•ç‹¬åˆ†åŒºï¼Œprefix å°±ä¸éœ€è¦å†™æˆ \\(hd1,gpt2\\)/boot/grubï¼Œæ¯•ç«Ÿå·²ç»åœ¨ /boot é‡Œé¢äº†å˜›ã€‚é»˜è®¤æ²¡æœ‰ GPT æ”¯æŒï¼Œæ‰€ä»¥è¿˜éœ€è¦æ·»åŠ  GPT æ¨¡å—ã€‚\nç”Ÿæˆå¯åŠ¨é•œåƒï¼š\næŒ‰ç…§ GRUB çš„å¸®åŠ©æ–‡æ¡£ï¼Œlnxboot.img éœ€è¦æ”¾åœ¨ core.img ä¹‹å‰ï¼Œç”± lnxboot.img æ¥åŠ è½½ core.imgã€‚æ‰€å¹¸ BCD å¯ä»¥ä¸€æ¬¡è¯»å–å¤§äºä¸€ä¸ªæ‰‡åŒºï¼ˆ512Bï¼‰çš„å†…å®¹ï¼Œæ‰€ä»¥å°†è¿™ä¸¤ä¸ªæ–‡ä»¶åˆå¹¶ä¸€ä¸‹å³å¯ï¼š\nsudo cat /usr/lib/grub/i386-pc/lnxboot.img /tmp/core.img \u0026gt; /tmp/grub4bcd.img\nç„¶åå°† grub4bcd.img æ”¾åˆ° Windows å¯åŠ¨åˆ†åŒºæ ¹ç›®å½•ä¸‹é¢å°±å¯ä»¥äº†ã€‚æ³¨æ„å†…æ ¸é»˜è®¤åªèƒ½ä»¥åªè¯»æ¨¡å¼æŒ‚è½½ NFTS æ–‡ä»¶ç³»ç»Ÿï¼Œéœ€è¦å®‰è£…æ‰©å±•åŒ…æ‰èƒ½è¯»å†™ï¼š\nsudo pacman -S ntfs-3g\nç„¶åæŒ‚è½½ï¼ˆå®‰è£…äº†ä¸Šè¿°æ‰©å±•åŒ…ä¹‹åç”šè‡³ä¸ç”¨æŒ‡å®šå‚æ•°ï¼‰ï¼š\nsudo mount /dev/sda1 /mnt/reserved\nç°åœ¨å°±å¯ä»¥é¡ºåˆ©åœ°å°†å¯åŠ¨é•œåƒå¤åˆ¶åˆ° Windows å¯åŠ¨åˆ†åŒºä¸‹é¢äº†ã€‚\n0x05 åœ¨ BCD ä¸­æ·»åŠ å¼•å¯¼èœå• é‡å¯è¿›å…¥ Windows 10ã€‚ä»¥ç®¡ç†å‘˜æƒé™æ‰“å¼€å‘½ä»¤è¡Œã€‚\næ·»åŠ å…¥å£ï¼š\nbcdedit /create /d \u0026quot;Switch to GRUB\u0026quot; /application bootsector\nä¼šè¿”å›ä¸€ä¸² UUIDï¼Œå¤åˆ¶ä¸‹æ¥ã€‚ä¹‹å UUID çš„åœ°æ–¹æˆ‘ç”¨ {ID} è¡¨ç¤ºï¼Œç”¨åˆšæ‰å¾—åˆ°çš„æ›¿æ¢å³å¯ã€‚\nè®¾ç½®å¯åŠ¨åˆ†åŒºï¼š\nbcdedit /set {ID} device boot\nè®¾ç½®å¯åŠ¨æ–‡ä»¶ï¼š\nBcdedit /set {ID} path /grub4bcd.img\nå°†å…¥å£æ·»åŠ è¿›å¯åŠ¨èœå•ï¼š bcdedit /displayorder {ID} /addlast\nå…³é—­ Metro å¯åŠ¨èœå•ï¼ˆä¸å…³é—­çš„è¯åˆ‡æ¢æ—¶ä¼šé‡å¯ï¼Œå»ºè®®å…³é—­ï¼‰ï¼š\nbcdedit /set {default} bootmenupolicy legacy\næœ€åå…³é—­ Windows 10 çš„ Hybrid å¼€æœºåŠŸèƒ½ï¼Œå¦åˆ™å¯èƒ½ä¼šå¯¼è‡´ Windows ä¸¢å¤±æ•°æ®ï¼š\npowercfg /h off\n0x06 åè®° ç°åœ¨ç»ˆäºå¯ä»¥æ„‰å¿«åœ°åˆ‡æ¢ä¸¤ä¸ªå¼•å¯¼èœå•äº†ã€‚å…¶å®ä½¿ç”¨ GRUB æ¥ç®¡ç†ä¸¤ä¸ªç³»ç»Ÿæ˜¯è¾ƒä¸ºç®€å•çš„åŠæ³•ã€‚\næ›´ä¸ºç®€å•çš„åŠæ³•æ˜¯ï¼Œå…ˆè£… Windows ç„¶åè£… Ubuntuï¼Œåè€…ä¼šè‡ªåŠ¨æå®šè¿™äº›éº»çƒ¦äº‹ã€‚â•®(â•¯_â•°)â•­\n0x07 å‚è€ƒèµ„æ–™ https://www.gnu.org/software/grub/manual/grub.html#Images\nhttp://askubuntu.com/questions/180033/how-to-add-different-drive-ubuntu-to-bcd-manually\nhttps://wiki.archlinux.org/index.php/Talk:Dual_boot_with_Windows\nhttps://wiki.archlinux.org/index.php/Dual_boot_with_Windows\n","date":"2017-04-05T19:26:41Z","permalink":"https://peromage.github.io/p/windows-linux-%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E6%89%8B%E8%AE%B0/","title":"Windows + Linux åŒç³»ç»Ÿå¼•å¯¼æ‰‹è®°"}]