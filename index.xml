<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Skag Den</title><link>https://peromage.github.io/</link><description>Recent content on Skag Den</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 14 Aug 2021 10:29:09 -0400</lastBuildDate><atom:link href="https://peromage.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Moving From Vim to Emacs</title><link>https://peromage.github.io/p/moving-from-vim-to-emacs/</link><pubDate>Sat, 14 Aug 2021 10:29:09 -0400</pubDate><guid>https://peromage.github.io/p/moving-from-vim-to-emacs/</guid><description>&lt;p>YouTube has been pushing me a lot Emacs related contents. This is weird since mostly I watch Vim videos only. But probably this is also a great opportunity to try Emacs again.&lt;/p>
&lt;p>I have tried Emacs half year ago. I looked a lot Elisp programming fundamentals and tried a few Emacs configurations from others including Doom Emacs. However, it didn&amp;rsquo;t last long since I found that I didn&amp;rsquo;t have enough time to configure this Emacs setup as good as the Vim setup that I was using. Also using other&amp;rsquo;s configurations makes things become complicated for me. They have too many packages included and I don&amp;rsquo;t what they are whether they are useful for me or not.&lt;/p>
&lt;p>After watching a bunch of Emacs videos I decided to pick it up this time, with vanilla Emacs starting from scratch. The reason why I make my mind this time is because I found Emacs can perfectly and elegantly solve some problems that pain my ass:&lt;/p>
&lt;ul>
&lt;li>More convenient package management.&lt;/li>
&lt;li>High quality packages.&lt;/li>
&lt;li>Easier file management in shell environment (Dired)&lt;/li>
&lt;li>No third party dependencies like Node.js and Python.
The two major plugs that I&amp;rsquo;m using in Vim are Coc and Leaderf. They require Node.js and Python to work. Since Elisp is power enough, Emacs can handle this easily by itself.&lt;/li>
&lt;li>Server-client architecture.
I can even replace Tmux with Emacs now. NeoVim has the similar concept but it cannot match what Emacs has.&lt;/li>
&lt;li>Graphical interface in X mode.
This makes Emacs be able to display rich contents.&lt;/li>
&lt;li>Org mode.
It looks great to organize to-do list and take notes without switching to other applications.&lt;/li>
&lt;li>Evil mode.
No need to worry about missing Vim&amp;rsquo;s features.&lt;/li>
&lt;li>Elisp
Right. Elisp is fun. :)&lt;/li>
&lt;/ul>
&lt;p>The migration is going slowly. Right now my main setup is still Vim + Tmux. There is a little curve learning from vanilla edition of Emacs, but It&amp;rsquo;s not a big deal compared with the first time when I started learning Vim.&lt;/p>
&lt;p>In the end, I want to say that Vim and Emacs both are great text editor. For me, Vim is more like a spirit, a concept. Once you&amp;rsquo;ve learned its high-efficiency key maps, you can use it everywhere. Even though I switch to Emacs I still use Vim mode together with Emacs' powerful extendability. Why not?&lt;/p></description></item><item><title>Dual-booting Windows VHD and Native Linux on a BIOS+GPT PC</title><link>https://peromage.github.io/p/dual-booting-windows-vhd-and-native-linux-on-a-bios-gpt-pc/</link><pubDate>Fri, 09 Jul 2021 16:40:31 +0000</pubDate><guid>https://peromage.github.io/p/dual-booting-windows-vhd-and-native-linux-on-a-bios-gpt-pc/</guid><description>&lt;h1 id="background">Background&lt;/h1>
&lt;p>Previously I wrote a post for this dual-boot scenario. It is a little outdated. In the past year I mostly worked in the Linux environment on my old laptop, so the Windows seems not to be a necessity which occupies a dedicated partition. However, sometimes it is still needed. That is why I started thinking to improve this setup even further.&lt;/p>
&lt;p>Starting from Windows 7, Windows supports boots from a VHD file which makes it so much easier to manage. Also you are able to create differencing disks which are pretty much like snapshots.&lt;/p>
&lt;p>For this new configuration, my plan is to use &lt;em>BIOS + GPT disk table + Native Linux + Native Windows booting from VHD + GRUB as the bootloader&lt;/em>.&lt;/p>
&lt;h1 id="partitioning">Partitioning&lt;/h1>
&lt;p>To make GPT works with BIOS. It is required to have a small partition &lt;a class="link" href="https://wiki.archlinux.org/title/GRUB" target="_blank" rel="noopener"
>flagged&lt;/a> with &lt;code>EF02&lt;/code>.&lt;/p>
&lt;p>The partition scheme looks like this:&lt;/p>
&lt;pre>&lt;code>Device Start End Sectors Size Type
/dev/sda1 34 2047 2014 1007K BIOS boot
/dev/sda2 2048 1026047 1024000 500M EFI System
/dev/sda3 1026048 206546943 205520896 98G Linux filesystem
/dev/sda4 206546944 835692543 629145600 300G Linux filesystem
/dev/sda5 835692544 1465149134 629456591 300.1G Microsoft basic data
&lt;/code>&lt;/pre>&lt;h1 id="installing-linux">Installing Linux&lt;/h1>
&lt;p>Any Linux distro would work. I chose Manjaro KDE this time because I found that the Pop OS made my laptop really hot sometimes (Yeah KDE is prettier).&lt;/p>
&lt;p>This part should be easy. The GRUB files is going into that EFI partition. For details, check &lt;a class="link" href="https://wiki.archlinux.org/title/GRUB" target="_blank" rel="noopener"
>GRUB wiki&lt;/a>.&lt;/p>
&lt;h1 id="preparing-to-install-windows">Preparing to Install Windows&lt;/h1>
&lt;p>I&amp;rsquo;m not going to use the standard Windwos installer since I want to install it into a VHD file. To make it work we need a Windows PE environment.&lt;/p>
&lt;h2 id="preparing-images">Preparing Images&lt;/h2>
&lt;p>Any Windows PE (Windows 7 and above) would work. The PE ISO image is going to &lt;code>/boot/wepe.iso&lt;/code>.&lt;/p>
&lt;p>Also a Windows ISO image is needed. For example a Windows 7 ISO named &lt;code>windows7.iso&lt;/code> will be put in the Windows data partition.&lt;/p>
&lt;h2 id="adding-windows-pe-to-grub">Adding Windows PE to GRUB&lt;/h2>
&lt;p>Boot into Linux. Download Windows PE ISO file and move it to the EFI partition (EXT4 partitions might be problematic).&lt;/p>
&lt;p>To load this ISO image, &lt;code>memdisk&lt;/code> tool from &lt;code>syslinux&lt;/code> is required. Steps as below on Arch based distro:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># Installing syslinux&lt;/span>
$ sudo pacman -S syslinux
&lt;span class="c1"># Copying `memdisk` to the boot partition&lt;/span>
$ sudo cp /usr/lib/syslinux/bios/memdisk /boot/memdisk
&lt;span class="c1"># Adding Windows PE entry to GRUB. 1DB1-9C31 is the boot partition&amp;#39;s UUID&lt;/span>
$ sudo cat &lt;span class="s">&amp;lt;&amp;lt;EOF &amp;gt;&amp;gt;/etc/grub.d/40_custom
&lt;/span>&lt;span class="s">menuentry &amp;#34;WePE x64&amp;#34; {
&lt;/span>&lt;span class="s"> search --set=root --no-floppy --fs-uuid 1DB1-9C31
&lt;/span>&lt;span class="s"> linux16 /memdisk iso ro
&lt;/span>&lt;span class="s"> initrd16 /wepe.iso
&lt;/span>&lt;span class="s">}
&lt;/span>&lt;span class="s">EOF&lt;/span>
&lt;span class="c1"># Updating GRUB entries&lt;/span>
$ sudo grub-mkconfig -o /boot/grub/grub.cfg
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="installing-windows-to-a-vhd-file">Installing Windows to a VHD File&lt;/h1>
&lt;p>After adding Windows PE to the bootloader entries, it is time to switch the working environment.&lt;/p>
&lt;p>Restart the PC, then keep pression &lt;code>shift&lt;/code> key until the GRUB menu shows up. Now navigate to the Windows PE entry and get in there.&lt;/p>
&lt;h2 id="creating-a-vhd-file-for-windows">Creating a VHD File for Windows&lt;/h2>
&lt;p>To create a VHD file, open a command line window and enter &lt;code>diskpart&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cmd" data-lang="cmd"># Create a VHD file assuming the NTFS data partition is assigned with D:
DISKPART&lt;span class="p">&amp;gt;&lt;/span> create vdisk file=d:\windows7.vhd maximum=64000 type=fixed
DISKPART&lt;span class="p">&amp;gt;&lt;/span> select vdisk file=d:\windows7.vhd
DISKPART&lt;span class="p">&amp;gt;&lt;/span> attach vdisk
# Disk table type doesn&amp;#39;t matter but using MBR for better compatibility
DISKPART&lt;span class="p">&amp;gt;&lt;/span> convert mbr
# Create the system partition and assign it with C:
DISKPART&lt;span class="p">&amp;gt;&lt;/span> create partition primary
DISKPART&lt;span class="p">&amp;gt;&lt;/span> format fs=ntfs quick
DISKPART&lt;span class="p">&amp;gt;&lt;/span> assign letter=c
DISKPART&lt;span class="p">&amp;gt;&lt;/span> exit
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now the Windows image can be dumped into this VHD file.&lt;/p>
&lt;h2 id="extracting-windows-image">Extracting Windows Image&lt;/h2>
&lt;p>Mount the Windows ISO image to &lt;code>E:&lt;/code> volume and open a command line window&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cmd" data-lang="cmd"># Get the image index. For example the desired version&amp;#39;s index is 1
&lt;span class="p">&amp;gt;&lt;/span> dism /get-wiminfo /wimfile=e:\sources\install.wim
# Extract the image. Where E: is the Windows ISO and C: is the VHD file
&lt;span class="p">&amp;gt;&lt;/span> dism /apply-image /imagefile:e:\sources\install.wim /index:1 /applydir:c:\
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="fixing-the-windows-bootloader">Fixing the Windows Bootloader&lt;/h1>
&lt;p>Stay in Windows PE. Don&amp;rsquo;t restart the PC. We still need to fix the bootloader for Windows.&lt;/p>
&lt;p>Normally Windows cannot be booted with a GPT+MBR setup. And also loading the whole Windows VHD file through &lt;code>memdisk&lt;/code> is not possible because it&amp;rsquo;s too large to load into memory. To fix the boot issue a bridge is needed between Windows and GRUB.&lt;/p>
&lt;p>Luckily &lt;a class="link" href="http://reboot.pro/index.php?showtopic=19516&amp;amp;page=2&amp;amp;#entry184489" target="_blank" rel="noopener"
>a small VHD image&lt;/a> can still be loaded by &lt;code>memdisk&lt;/code>.&lt;/p>
&lt;p>The idea is: GRUB -&amp;gt; MS Bootmgr VHD -&amp;gt; Windows VHD&lt;/p>
&lt;h2 id="creating-a-dedicated-bootloader-image-for-windows">Creating a Dedicated Bootloader Image for Windows&lt;/h2>
&lt;p>It is same with the process creating a VHD file for Windows system but this time it is a smaller file (32 MB).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cmd" data-lang="cmd"># Create a small bootmgr VHD file in the data partition
DISKPART&lt;span class="p">&amp;gt;&lt;/span> create vdisk file=d:\bootmgr.vhd maximum=32 type=fixed
DISKPART&lt;span class="p">&amp;gt;&lt;/span> select vdisk file=d:\bootmgr.vhd
DISKPART&lt;span class="p">&amp;gt;&lt;/span> attach vdisk
DISKPART&lt;span class="p">&amp;gt;&lt;/span> convert mbr
DISKPART&lt;span class="p">&amp;gt;&lt;/span> create partition primary
DISKPART&lt;span class="p">&amp;gt;&lt;/span> format fs=ntfs quick
DISKPART&lt;span class="p">&amp;gt;&lt;/span> assign letter=f
DISKPART&lt;span class="p">&amp;gt;&lt;/span> exit
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now the &lt;code>bootmgr&lt;/code> VHD is mounted at F:. Then write the boot record and create boot configuration files.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cmd" data-lang="cmd">&lt;span class="p">&amp;gt;&lt;/span> bootsect /nt60 f: /mbr
&lt;span class="p">&amp;gt;&lt;/span> bcdboot c:\Windows /l en-us /s f: /f bios
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="fixing-the-bcd-entry">Fixing the BCD Entry&lt;/h2>
&lt;p>At this point it should be working according to the &lt;a class="link" href="https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/boot-to-vhd--native-boot--add-a-virtual-hard-disk-to-the-boot-menu" target="_blank" rel="noopener"
>Microsoft&amp;rsquo;s document&lt;/a>. In fact it is not.&lt;/p>
&lt;p>Let&amp;rsquo;s check the BCD entries, in a command window:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cmd" data-lang="cmd">&lt;span class="p">&amp;gt;&lt;/span> bcdedit /store f:\Boot\BCD /enum
Windows Boot Manager
--------------------
identifier {bootmgr}
device partition=F:
description Windows Boot Manager
locale en-us
inherit {globalsettings}
default {default}
resumeobject {fcd67427-e033-11eb-8826-cdf90e3873d0}
displayorder {default}
toolsdisplayorder {memdiag}
timeout 30
Windows Boot Loader
-------------------
identifier {default}
device partition=C:
&lt;span class="k">path&lt;/span> \Windows\system32\winload.exe
description Windows 7
locale en-us
inherit {bootloadersettings}
osdevice partition=C:
systemroot \Windows
resumeobject {fcd67427-e033-11eb-8826-cdf90e3873d0}
nx OptIn
detecthal Yes
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>device&lt;/code> and &lt;code>osdevice&lt;/code> seems to be right but once the Windows VHD is unmounted it becomes &lt;code>unknown&lt;/code>. According to this &lt;a class="link" href="http://www.mistyprojects.co.uk/documents/BCDEdit/files/device.htm" target="_blank" rel="noopener"
>BCDEdit notes&lt;/a>, BCD entry records the partition&amp;rsquo;s information such as UUID to find the correct partition during bootup. In this case the partition can&amp;rsquo;t be found until the VHD file is mounted. But this VHD file is not mounted automatically.&lt;/p>
&lt;p>Thus we need to correct this and let &lt;code>Bootmgr&lt;/code> locate the VHD file properly.&lt;/p>
&lt;p>In a command line window:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cmd" data-lang="cmd"># The identifier must match the one which is showing above
&lt;span class="p">&amp;gt;&lt;/span> bcdedit /store C:\Boot\BCD /set {default} device vhd=[D:]\windows7.vhd
&lt;span class="p">&amp;gt;&lt;/span> bcdedit /store C:\Boot\BCD /set {default} osdevice vhd=[D:]\windows7.vhd
&lt;/code>&lt;/pre>&lt;/div>&lt;p>If we check the BCD entry again it doesn&amp;rsquo;t change. But if we unmount the Windows VHD it will become:&lt;/p>
&lt;pre>&lt;code>&amp;gt; bcdedit /store f:\Boot\BCD /enum
Windows Boot Manager
--------------------
identifier {bootmgr}
device partition=E:
description Windows Boot Manager
locale en-us
inherit {globalsettings}
default {default}
resumeobject {fcd67427-e033-11eb-8826-cdf90e3873d0}
displayorder {default}
toolsdisplayorder {memdiag}
timeout 30
Windows Boot Loader
-------------------
identifier {default}
device vhd=[C:]\windows7.vhd
path \Windows\system32\winload.exe
description Windows 7
locale en-us
inherit {bootloadersettings}
osdevice vhd=[C:]\windows7.vhd
systemroot \Windows
resumeobject {fcd67427-e033-11eb-8826-cdf90e3873d0}
nx OptIn
detecthal Yes
&lt;/code>&lt;/pre>&lt;p>The volume letter doesn&amp;rsquo;t matter, it changes dynamically. Now &lt;code>bootmgr&lt;/code> is able to locate the VHD file correctly.&lt;/p>
&lt;h1 id="adding-windows-to-grub">Adding Windows to GRUB&lt;/h1>
&lt;p>Restart PC and get into Linux.&lt;/p>
&lt;p>Modify the GRUB config file to load &lt;code>bootmgr&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># Adding Windows (bootmgr) entry to GRUB. 1DB1-9C31 is the boot partition&amp;#39;s UUID&lt;/span>
$ sudo cat &lt;span class="s">&amp;lt;&amp;lt;EOF &amp;gt;&amp;gt;/etc/grub.d/40_custom
&lt;/span>&lt;span class="s">menuentry &amp;#34;Windows 7&amp;#34; {
&lt;/span>&lt;span class="s"> search --set=root --no-floppy --fs-uuid 1DB1-9C31
&lt;/span>&lt;span class="s"> linux16 /memdisk harddisk
&lt;/span>&lt;span class="s"> initrd16 /bootmgr.vhd
&lt;/span>&lt;span class="s">}
&lt;/span>&lt;span class="s">EOF&lt;/span>
&lt;span class="c1"># Updating GRUB entries&lt;/span>
$ sudo grub-mkconfig -o /boot/grub/grub.cfg
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now we can restart PC. Keep pressing &lt;code>shift&lt;/code> on bootup to go to the GRUB menu. Select Windows entry to boot Windows.&lt;/p>
&lt;h1 id="fixing-windows-initialization-error">Fixing Windows Initialization Error&lt;/h1>
&lt;p>During the first time bootup, Windows might have an error showing &lt;em>Windows could not complete the installation. To install Windows on this computer, restart the installation&lt;/em>.&lt;/p>
&lt;p>To &lt;a class="link" href="https://www.howisolve.com/windows-could-not-complete-the-installation-solved/" target="_blank" rel="noopener"
>solve&lt;/a> this error:&lt;/p>
&lt;ol>
&lt;li>Press &lt;code>SHIFT + F10&lt;/code> to bring up the command prompt.&lt;/li>
&lt;li>Execute &lt;code>C:\windows\system32\oobe\msoobe&lt;/code>.&lt;/li>
&lt;li>Wait for a while and the setup window will show up.&lt;/li>
&lt;li>Complete the setup and restart.&lt;/li>
&lt;/ol>
&lt;h1 id="creating-a-differencing-disk">Creating a Differencing Disk&lt;/h1>
&lt;p>A differencing disk can be used for quick recoveries.&lt;/p>
&lt;p>To create it, restart into the Windows PE environment. In a command line window:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cmd" data-lang="cmd"># Use the original VHD as base
&lt;span class="p">&amp;gt;&lt;/span> move d:\windows7.vhd d:\windows7_base.vhd
# Create a differencing disk based on the original one
# The name of the new differencing disk has to be the name that was recorded in the BCD
&lt;span class="p">&amp;gt;&lt;/span> diskpart
DISKPART&lt;span class="p">&amp;gt;&lt;/span> creat vdisk file=d:\windows7.vhd parent=d:\windows7_base.vhd
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then all changes made in the future will go into the differencing disk. If system goes wrong one day, simply deleting the the differencing disk and creating a new one would quickly recover from the crysis.&lt;/p>
&lt;p>&lt;strong>NOTE: After creating the differencing disk, the base VHD is not supposed to be modified.&lt;/strong>&lt;/p>
&lt;h1 id="references">References&lt;/h1>
&lt;ul>
&lt;li>&lt;a class="link" href="https://wiki.archlinux.org/title/GRUB" target="_blank" rel="noopener"
>GRUB wiki&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://wzyboy.im/post/1049.html" target="_blank" rel="noopener"
>BIOS + GPT + GRUB + Linux + Windows 折腾笔记&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://rimo.site/2017/02/08/install-win7-into-vhd/" target="_blank" rel="noopener"
>在 VHD 中安装 Windows 7&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="http://reboot.pro/index.php?showtopic=19516&amp;amp;page=2&amp;amp;#entry184489" target="_blank" rel="noopener"
>Hack Bootmgr to boot Windows in BIOS to GPT&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/boot-to-vhd--native-boot--add-a-virtual-hard-disk-to-the-boot-menu" target="_blank" rel="noopener"
>Boot to a virtual hard disk: Add a VHDX or VHD to the boot menu&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="http://www.mistyprojects.co.uk/documents/BCDEdit/files/device.htm" target="_blank" rel="noopener"
>BCDEdit notes&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.howisolve.com/windows-could-not-complete-the-installation-solved/" target="_blank" rel="noopener"
>100% Solved:Windows could not complete the installation&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Git 中的 Subtree 和 Submodule</title><link>https://peromage.github.io/p/git-%E4%B8%AD%E7%9A%84-subtree-%E5%92%8C-submodule/</link><pubDate>Fri, 07 Apr 2017 20:53:53 +0000</pubDate><guid>https://peromage.github.io/p/git-%E4%B8%AD%E7%9A%84-subtree-%E5%92%8C-submodule/</guid><description>&lt;p>因为最近弄自己的博客，涉及到了版本库嵌套的问题。记下来也算是给自己一个备忘。&lt;/p>
&lt;h1 id="为什么有这样的需求">为什么有这样的需求&lt;/h1>
&lt;p>版本库嵌套很好理解，就是在一个 Git 仓库里面包含了其他的 Git 仓库。通常有这样的需求往往涉及到协同开发。比如这里有一个插件单独的 Git 仓库姑且叫“Plugin”。现在我创建了一个自己的项目，其中需要用到这个“Plugin”插件。通常比较笨的办法就是把插件库源码拖下来，复制到自己的项目里。但是这样当插件库更新的时候，插件源码更新往往比较麻烦。而且如果在使用的过程中修改了插件的源码，也不便于插件单独的版本控制，更别说为插件库贡献代码了。但如果插件单独以 Git 仓库存在于我的项目目录中，以上的问题就解决了。&lt;/p>
&lt;p>在 Git 里面提供了两种方式实现上述需求，那就是 Subtree 和 Submodule。&lt;/p>
&lt;h1 id="submodule">Submodule&lt;/h1>
&lt;p>Submodule 是 Git 里面最早提供的一种方法。顾名思义“子模块”。&lt;/p>
&lt;h2 id="添加子模块">添加子模块&lt;/h2>
&lt;p>执行&lt;br>
&lt;code>git submodule add &amp;lt;repo&amp;gt; &amp;lt;module_path&amp;gt;&lt;/code>&lt;/p>
&lt;p>此时运行 &lt;code>git status&lt;/code> 可以看到子模块对应的文件夹和一个叫做 &lt;em>.gitmodules&lt;/em> 文件被添加进了暂存区。其中*.gitmodules*是用于记录子模块相关信息的。之后主项目里面的操作照常提交就可以了。&lt;/p>
&lt;h2 id="修改子模块">修改子模块&lt;/h2>
&lt;p>但如果在开发的途中修改了子模块的代码，需要单独到子模块对应的根目录里面进行子模块单独的提交操作。在主项目里面虽然可以看到子模块有变更，但是无法看到具体的更改操作，而是将其看作一个模块整体。一旦子模块产生了新的提交，主项目里面可以看到子模块的 HEAD 变化，从而主项目也应当产生一个新的提交以记录对应关系。&lt;br>
换句话说，主项目就是靠着记录子模块 HEAD 值来判断依赖的。&lt;strong>子模块的代码最后将不会进入主项目的版本库里面（只有 HEAD 值）&lt;/strong>&lt;/p>
&lt;p>现在子模块有了新的提交，为了将服务器上的代码更新，我们只需要进入子模块对应的更目录执行 push 操作就可以了。&lt;/p>
&lt;h2 id="更新子模块">更新子模块&lt;/h2>
&lt;p>此时子模块上游有了新的代码，我们需要将其整合到当前的项目中。有两种方法。&lt;/p>
&lt;p>在主项目根目录下运行&lt;br>
&lt;code>git submodule foreach git pull&lt;/code>&lt;/p>
&lt;p>或者切换到子模块的根目录下面
&lt;code>git pull&lt;/code>&lt;/p>
&lt;h2 id="克隆项目">克隆项目&lt;/h2>
&lt;p>克隆主项目的时候子模块并不会拉取到本地，如果进入对应的目录会发现是空的。&lt;br>
此时应当&lt;br>
&lt;code>git submodule init&lt;/code>&lt;br>
保持最新&lt;br>
&lt;code>git submodule update&lt;/code>&lt;/p>
&lt;p>或者可以直接一条命令搞定&lt;br>
&lt;code>git clone --recursive &amp;lt;repo&amp;gt;&lt;/code>&lt;/p>
&lt;h2 id="删除子模块">删除子模块&lt;/h2>
&lt;p>Git 中没有提供直接删除的命令，需要手动完成删除操作。&lt;/p>
&lt;p>反向初始化子模块&lt;br>
&lt;code>git submodule deinit --force &amp;lt;module_path&amp;gt;&lt;/code>&lt;br>
或者直接删掉 &lt;em>.git/config&lt;/em> 里相关信息&lt;/p>
&lt;p>移除子模块&lt;br>
&lt;code>git rm &amp;lt;module_path&amp;gt;&lt;/code>&lt;/p>
&lt;p>如果暂存区还有
&lt;code>git rm --cached &amp;lt;module_path&amp;gt;&lt;/code>&lt;/p>
&lt;h2 id="子模块的坑">子模块的坑&lt;/h2>
&lt;h3 id="提交的坑">提交的坑&lt;/h3>
&lt;p>假设有 A B 两个人同时在开发一个项目，这个项目里面也包含了一个子模块。此时 A 修改了业务代码，同时修改了一个子模块里面的一个 bug 。A 将这次修改提交，主项目的提交里面指向了子模块新的 HEAD1 ，然后把主项目的版本库 push 到了服务器，但是没有 push 子模块。B 此时 pull 了主项目，然后 update 子模块，被告知找不到子模块的 HEAD1 。因为指向 HEAD1 的提交还在 A 本地机器上。&lt;br>
这就是子模块提交的坑。在多个模块存在的时候操作非常繁琐。&lt;/p>
&lt;h3 id="初始化的坑">初始化的坑&lt;/h3>
&lt;p>在执行 &lt;code>git submodule init&lt;/code>， &lt;code>git submodule update&lt;/code> 之后，此时修改子模块可能出现 HEAD 处于游离状态的的提示。如果不注意极有可能出现丢失提交的可能。&lt;br>
解决办法，在以上两条命令之后执行一次检出&lt;br>
&lt;code>git checkout &amp;lt;branch&amp;gt;&lt;/code>&lt;/p>
&lt;h1 id="subtree">Subtree&lt;/h1>
&lt;h2 id="添加子项目">添加子项目&lt;/h2>
&lt;p>首先添加子项目对应的远程服务器&lt;br>
&lt;code>git remote add &amp;lt;subrepo_name&amp;gt; &amp;lt;subrepo_remote&amp;gt;&lt;/code>&lt;/p>
&lt;p>拉取一下&lt;br>
&lt;code>git fetch &amp;lt;subrepo_name&amp;gt;&lt;/code>&lt;/p>
&lt;p>添加子项目到父项目里面&lt;br>
&lt;code>git subtree add --squash --prefix=&amp;lt;subrepo_path&amp;gt; &amp;lt;subrepo_name&amp;gt; &amp;lt;branch&amp;gt;&lt;/code>&lt;br>
参数 &lt;em>&amp;ndash;squash&lt;/em> 作用在于合并子项目所有提交为一个，并 merge 到父项目的历史中，这样只会出现两个提交记录，避免子项目的提交历史污染父项目。更多讨论可以看&lt;a class="link" href="http://www.fwolf.com/blog/post/246" target="_blank" rel="noopener"
>&lt;strong>这里&lt;/strong>&lt;/a>。&lt;/p>
&lt;h2 id="修改子项目">修改子项目&lt;/h2>
&lt;p>添加完毕之后照常修改提交各种操作，父项目能够跟踪子项目里面的所有变更。子项目被当做一个正常的子文件夹处理。&lt;/p>
&lt;p>如果现在修改了子项目里的一个 bug 并且想要反馈给上游，可以这样操作&lt;br>
&lt;code>git subtree push --prefix=&amp;lt;subrepo_path&amp;gt; &amp;lt;subrepo_name&amp;gt; &amp;lt;bug_fixed&amp;gt;&lt;/code>&lt;br>
这个操作可以将父项目里所有涉及子项目修改的提交检出。这样在远程仓库里面会出现一个叫做 &lt;em>bug_fixed&lt;/em> 的分支。&lt;/p>
&lt;p>或者也可以这样操作&lt;br>
&lt;code>git subtree split --prefix=&amp;lt;subrepo_path&amp;gt; --branch &amp;lt;new_branch_name&amp;gt;&lt;/code>&lt;br>
这个操作跟上面一样将父项目里所有涉及子项目修改的提交检出，并且把子项目的根文件夹设为整个项目的根文件夹，然后检出为父项目的一个新的分支。&lt;/p>
&lt;p>然后推送给上游&lt;br>
&lt;code>git push &amp;lt;subrepo_remote&amp;gt; &amp;lt;new_branch_name&amp;gt;:&amp;lt;bug_fixed&amp;gt;&lt;/code>&lt;/p>
&lt;p>之后删除对应本地分支就可以了。&lt;/p>
&lt;h2 id="更新子项目">更新子项目&lt;/h2>
&lt;p>拉取非常方便&lt;br>
&lt;code>git subtree pull --prefix=&amp;lt;subrepo_path&amp;gt; &amp;lt;subrepo_name&amp;gt; &amp;lt;branch&amp;gt;&lt;/code>&lt;/p>
&lt;h2 id="删除子项目">删除子项目&lt;/h2>
&lt;p>因为子项目在父项目里面就是被当做一个普通的文件夹处理的，所以直接移除文件夹并提交就可以了。&lt;/p>
&lt;h1 id="submodule-vs-subtree">Submodule vs. Subtree&lt;/h1>
&lt;p>Git 官方推荐使用新的 Subtree ，事实证明的确比 Submodule 方便不少。Subtree 不会产生额外的文件，而且子项目的代码包含在父项目里面，不会出现前面提到的坑的问题。具体应用上的对比可以参考&lt;a class="link" href="https://gist.github.com/kvnsmth/4688345" target="_blank" rel="noopener"
>&lt;strong>这篇文章&lt;/strong>&lt;/a>。Subtree 对于代码迭代较快的项目尤为适合。&lt;/p>
&lt;p>但也不是说 Submodule 一无是处， Submodule 在我感觉最大的意义在于可以隔离子项目的业务代码，并且记录严格的依赖关系。对于一些子模块更新较慢的项目还是比较适合的。&lt;/p></description></item><item><title>Windows + Linux 双系统引导手记</title><link>https://peromage.github.io/p/windows-linux-%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E6%89%8B%E8%AE%B0/</link><pubDate>Wed, 05 Apr 2017 19:26:41 +0000</pubDate><guid>https://peromage.github.io/p/windows-linux-%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E6%89%8B%E8%AE%B0/</guid><description>&lt;h1 id="0x00-情况简述">0x00 情况简述&lt;/h1>
&lt;p>由于开发需要 Linux 环境，所以将老的那台笔记本改造成了双系统。&lt;br>
这台电脑的基本情况是这样的，64GB 固态硬盘 + 720GB 机械硬盘（实际可用空间有折损，这里为了表示方便），Windows 10 已经安装到了固态硬盘上。由于主板较老，只能支持 BIOS。巨硬又说过 Windows 只能支持 BIOS + MBR，所以第一块主位（Master）上的固态硬盘就只能采用 MBR 分区表，分成了两个区，500MB 用作启动分区，剩下的部分全部划给了系统分区。&lt;br>
但是 Linux 表示没有巨硬这种尿性，所以为什么不使用更先进的 GPT 分区表？因此从位（Slave）上的机械硬盘被我分成了这个样子：&lt;br>
&lt;strong>10MB BIOS 启动分区（No File System） + 500MB /boot 启动挂载点（EXT4） + 100GB / 根挂载点（EXT4） + 199.5GB /home 用户目录挂载点（EXT4） + 420GB Windows 数据分区（NTFS）&lt;/strong>。&lt;br>
BIOS 启动分区 1MB 足以，我只是考虑到后续扩展问题。之后在第二块硬盘上安装了 Arch Linux。&lt;/p>
&lt;h1 id="0x01-有啥好折腾的">0x01 有啥好折腾的？&lt;/h1>
&lt;p>双系统安装好以后相安无事，BIOS 默认从主位固态硬盘启动。也就是说开机不进行任何操作的话，默认进入的是 Windows 10。只有在开机的时候使用 BIOS 的 Fast Boot 功能，选择从第二块硬盘启动才能进入 Arch Linux。换句话说两个系统彼此都是透明的。
但是作为一个强迫症和完美主义者，万一我想进入 Linux，但是开机的时候错过了，岂不是要重启一次才行？或者万一我又反悔想进入 Windows 又要重启一次？这怎么能忍，所以才有了这次的折腾……&lt;/p>
&lt;h1 id="0x02-在-grub-中添加引导菜单">0x02 在 GRUB 中添加引导菜单&lt;/h1>
&lt;p>对于 GRUB （注：这里所说的 GRUB 指的是 GRUB 2 而不是 GRUB Legacy） 引导的 Linux 来说，切换到 Windows 的 &lt;em>bootmgr&lt;/em> 是一件很容易的事情，最新版的 GRUB 可以直接启动 &lt;em>bootmgr&lt;/em> 而不需要之前的 chainloading 模式。
进入 Arch Linux，以 root 权限编辑 &lt;em>&lt;strong>/etc/grub.d/40_custom&lt;/strong>&lt;/em> ，加入以下菜单：&lt;/p>
&lt;pre>&lt;code>menuentry &amp;quot;Switch to Microsoft Boot Manager&amp;quot; {
insmod part_msdos
insmod ntfs
insmod search_fs_uuid
insmod ntldr
search --fs-uuid --set=root 69B235F6749E84CE
ntldr /bootmgr
}
&lt;/code>&lt;/pre>&lt;p>&lt;code>insmod&lt;/code> 是用于加载必要的模块以便 GRUB 识别并正确启动 Windows。值得注意的是，&lt;code>search&lt;/code> 一行指定的 UUID 与 Linux 下 &lt;strong>&lt;code>lsblk -f&lt;/code>&lt;/strong> 看到的 UUID 是不一样的，需要使用 &lt;strong>&lt;code>sudo grub-probe --target=fs_uuid -d /dev/sda1&lt;/code>&lt;/strong> 来获取 GRUB 下对应的分区 UUID。这个例子中，Windows 启动分区是 &lt;em>sda1&lt;/em>。UUID 是唯一的，勿照搬。&lt;/p>
&lt;p>当然也可以使用传统的 chainloading 模式：&lt;/p>
&lt;pre>&lt;code>menuentry &amp;quot;Switch to Microsoft Boot Manager&amp;quot; {
insmod part_msdos
insmod ntfs
insmod search_fs_uuid
search --fs-uuid --set=root 69B235F6749E84CE
chainloader +1
}
&lt;/code>&lt;/pre>&lt;p>保存以后，执行 &lt;strong>&lt;code>sudo grub-mkconfig -o /boot/grub/grub.cfg&lt;/code>&lt;/strong> ，以便更新启动菜单。&lt;br>
不推荐直接编辑 &lt;em>&lt;strong>/boot/grub/grub.cfg&lt;/strong>&lt;/em>，因为上述命令会覆盖这个文件，不便于自定义菜单的管理。&lt;br>
这样就可以直接跳转到 &lt;em>bootmgr&lt;/em>，让它去启动 Windows。&lt;/p>
&lt;h1 id="0x03-bcd-寻思">0x03 BCD 寻思&lt;/h1>
&lt;p>BCD 是Windows Vista 之后使用的一种启动管理器。有个非常蛋疼的问题就在于，BCD 并不支持 EXT4 分区格式，所以没有办法读到 GRUB。查阅了相关资料，给出的解决办法就是，将 &lt;em>&lt;strong>/boot&lt;/strong>&lt;/em> 分区格式化成 FAT32 的文件系统。难道我还得再折腾一次文件系统？直觉告诉我一定还有其他的办法。&lt;br>
既然 BCD 没办法直接读 EXT4 分区里面的东西，我们可以曲线救国。BCD 里面提供了一种实模式启动的方式，允许读取一个包含了启动代码的文件。所以一种解决办法就是 &lt;strong>BCD → MBR → VBR → Bootloader&lt;/strong>。由于 GPT 磁盘的第一个扇区被划分成了 Protective MBR，用于兼容 BIOS，所以在 Linux 使用：&lt;br>
&lt;strong>&lt;code>sudo dd if=/dev/sdb of=/mnt/reserved/grub.bin bs=512 count=1&lt;/code>&lt;/strong>&lt;br>
可以将第二块硬盘的第一扇区里面的启动代码导出到一个文件，然后使用 BCD 加载这个文件就可以启动 GRUB了。&lt;br>
果真如此？&lt;br>
事实是，这种方法可行，但是并不适用我的情况，因为这是建立在 Windows 和 Linux 安装在同一块硬盘上的情形。&lt;em>grub.bin&lt;/em> 并不能够跨分区寻找 VBR。难道只能作罢？肯定不可能，不然就没有这篇文章了。&lt;br>
查阅了若干文档之后，得知 GRUB 提供了一个 叫做 &lt;em>lnxboot.img&lt;/em> 文件，可以将 GRUB 启动阶段模拟成一个可以启动的 Linux 内核，然后挂载 &lt;em>core.img&lt;/em> 里面必要的模块，从而顺利启动 GRUB。那么将之前的思路修改成 &lt;strong>BCD → VBR → Bootloader&lt;/strong> 就行了，即既然 MBR 不能跨分区以及识别 GPT，那么我们就换成一个可以胜任的不就行了。&lt;/p>
&lt;h1 id="0x04-制作启动镜像">0x04 制作启动镜像&lt;/h1>
&lt;p>进入 Arch Linux。虽然在 &lt;em>&lt;strong>/boot/grub/i386-pc/&lt;/strong>&lt;/em> 目录下有一个用于启动的 &lt;em>core.img&lt;/em> 文件，这个文件里面指定的模块路径是相对路径，使用它启动依然会显示错误，需要指定绝对路径以保证万无一失。那么我们就来手动生成一个，顺便集成一些我们需要的模块。&lt;br>
注意，启动镜像稍后会被放在 Windows 的启动分区下面（BCD 的启动分区），所以还需要知道模块所在分区的位置。在 GRUB 中表示磁盘的方式有所不同，如 &lt;em>(hd0,msdos1)&lt;/em> 表示第一块磁盘，使用 MBR 分区表，第一个分区； &lt;em>(hd1,gpt2)&lt;/em> 表示第二块磁盘，使用 GPT分区表，第二个分区。括号不可省，磁盘和分区的起始数字不一样。&lt;/p>
&lt;p>使用 &lt;code>grub-probe&lt;/code> 来获取 &lt;em>&lt;strong>/boot&lt;/strong>&lt;/em> 分区信息。这个例子得到的是 &lt;em>hd1,gpt2&lt;/em>：&lt;br>
&lt;strong>&lt;code>sudo grub-probe --target=bios_hints /boot&lt;/code>&lt;/strong>&lt;/p>
&lt;p>生成 &lt;em>core.img&lt;/em>：&lt;br>
&lt;strong>&lt;code>sudo grub-mkimage --output=/tmp/core.img --prefix=\(hd1,gpt2\)/grub --format=i386-pc biosdisk part_msdos part_gpt ext2&lt;/code>&lt;/strong>&lt;br>
注意像我这样 &lt;em>&lt;strong>/boot&lt;/strong>&lt;/em> 单独分区，prefix 就不需要写成 &lt;em>&lt;strong>\(hd1,gpt2\)/boot/grub&lt;/strong>&lt;/em>，毕竟已经在 &lt;em>&lt;strong>/boot&lt;/strong>&lt;/em> 里面了嘛。默认没有 GPT 支持，所以还需要添加 GPT 模块。&lt;/p>
&lt;p>生成启动镜像：&lt;br>
按照 GRUB 的帮助文档，&lt;em>lnxboot.img&lt;/em> 需要放在 &lt;em>core.img&lt;/em> 之前，由 &lt;em>lnxboot.img&lt;/em> 来加载 &lt;em>core.img&lt;/em>。所幸 BCD 可以一次读取大于一个扇区（512B）的内容，所以将这两个文件合并一下即可：&lt;br>
&lt;strong>&lt;code>sudo cat /usr/lib/grub/i386-pc/lnxboot.img /tmp/core.img &amp;gt; /tmp/grub4bcd.img&lt;/code>&lt;/strong>&lt;/p>
&lt;p>然后将 &lt;em>grub4bcd.img&lt;/em> 放到 Windows 启动分区根目录下面就可以了。注意内核默认只能以只读模式挂载 NFTS 文件系统，需要安装扩展包才能读写：&lt;br>
&lt;strong>&lt;code>sudo pacman -S ntfs-3g&lt;/code>&lt;/strong>&lt;br>
然后挂载（安装了上述扩展包之后甚至不用指定参数）：&lt;br>
&lt;strong>&lt;code>sudo mount /dev/sda1 /mnt/reserved&lt;/code>&lt;/strong>&lt;/p>
&lt;p>现在就可以顺利地将启动镜像复制到 Windows 启动分区下面了。&lt;/p>
&lt;h1 id="0x05-在-bcd-中添加引导菜单">0x05 在 BCD 中添加引导菜单&lt;/h1>
&lt;p>重启进入 Windows 10。以管理员权限打开命令行。&lt;/p>
&lt;p>添加入口：&lt;br>
&lt;strong>&lt;code>bcdedit /create /d &amp;quot;Switch to GRUB&amp;quot; /application bootsector&lt;/code>&lt;/strong>&lt;br>
会返回一串 UUID，复制下来。之后 UUID 的地方我用 &lt;strong>{ID}&lt;/strong> 表示，用刚才得到的替换即可。&lt;/p>
&lt;p>设置启动分区：&lt;br>
&lt;strong>&lt;code>bcdedit /set {ID} device boot&lt;/code>&lt;/strong>&lt;/p>
&lt;p>设置启动文件：&lt;br>
&lt;strong>&lt;code>Bcdedit /set {ID} path /grub4bcd.img&lt;/code>&lt;/strong>&lt;/p>
&lt;p>将入口添加进启动菜单： &lt;br>
&lt;strong>&lt;code>bcdedit /displayorder {ID} /addlast&lt;/code>&lt;/strong>&lt;/p>
&lt;p>关闭 Metro 启动菜单（不关闭的话切换时会重启，建议关闭）：&lt;br>
&lt;strong>&lt;code>bcdedit /set {default} bootmenupolicy legacy&lt;/code>&lt;/strong>&lt;/p>
&lt;p>最后关闭 Windows 10 的 Hybrid 开机功能，否则可能会导致 Windows 丢失数据：&lt;br>
&lt;strong>&lt;code>powercfg /h off&lt;/code>&lt;/strong>&lt;/p>
&lt;h1 id="0x06-后记">0x06 后记&lt;/h1>
&lt;p>现在终于可以愉快地切换两个引导菜单了。其实使用 GRUB 来管理两个系统是较为简单的办法。&lt;br>
更为简单的办法是，先装 Windows 然后装 Ubuntu，后者会自动搞定这些麻烦事。╮(╯_╰)╭&lt;/p>
&lt;h1 id="0x07-参考资料">0x07 参考资料&lt;/h1>
&lt;p>&lt;em>&lt;a class="link" href="https://www.gnu.org/software/grub/manual/grub.html#Images" target="_blank" rel="noopener"
>https://www.gnu.org/software/grub/manual/grub.html#Images&lt;/a>&lt;/em>&lt;br>
&lt;em>&lt;a class="link" href="http://askubuntu.com/questions/180033/how-to-add-different-drive-ubuntu-to-bcd-manually" target="_blank" rel="noopener"
>http://askubuntu.com/questions/180033/how-to-add-different-drive-ubuntu-to-bcd-manually&lt;/a>&lt;/em>&lt;br>
&lt;em>&lt;a class="link" href="https://wiki.archlinux.org/index.php/Talk:Dual_boot_with_Windows" target="_blank" rel="noopener"
>https://wiki.archlinux.org/index.php/Talk:Dual_boot_with_Windows&lt;/a>&lt;/em>&lt;br>
&lt;em>&lt;a class="link" href="https://wiki.archlinux.org/index.php/Dual_boot_with_Windows" target="_blank" rel="noopener"
>https://wiki.archlinux.org/index.php/Dual_boot_with_Windows&lt;/a>&lt;/em>&lt;/p></description></item></channel></rss>